#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Akamai AIæ¨ç†äº‘å¹¿å‘Šè§†é¢‘ç”Ÿæˆè„šæœ¬
ä½¿ç”¨DeepSeek APIç”Ÿæˆè„šæœ¬ï¼ŒWavespeedAI APIç”Ÿæˆè§†é¢‘å’ŒéŸ³é¢‘
"""

import os
import json
import requests
import time
import sys
import io
import argparse
import subprocess
import yaml
from datetime import datetime
from dotenv import load_dotenv
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor, as_completed
from services.rate_limiter import RateLimiter
from services.voice_service import VoiceService
from services.subtitle_service import SubtitleService
from services.video_composer import VideoComposer
from services.music_service import MusicService

# ä¼˜å…ˆä½¿ç”¨Python 3.11+çš„å†…ç½®tomllibï¼Œå¦åˆ™ä½¿ç”¨tomlåº“
try:
    import tomllib
    def load_toml(file_path):
        with open(file_path, 'rb') as f:
            return tomllib.load(f)
except ImportError:
    import toml
    def load_toml(file_path):
        return toml.load(file_path)

# è®¾ç½®æ ‡å‡†è¾“å…¥è¾“å‡ºçš„ç¼–ç ä¸ºUTF-8ï¼Œå®½å®¹å¤„ç†ç»ˆç«¯ä¼ å…¥çš„å¼‚å¸¸å­—èŠ‚ä»¥é¿å…äº¤äº’ä¸­æ–­
sys.stdin = io.TextIOWrapper(sys.stdin.buffer, encoding='utf-8', errors='replace')
sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8', errors='replace')
sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8', errors='replace')

# ============================================================
# ç»ˆç«¯é¢œè‰²å®šä¹‰ (ANSIé¢œè‰²ä»£ç )
# ============================================================
class Colors:
    """ç»ˆç«¯é¢œè‰²å¸¸é‡"""
    # åŸºç¡€é¢œè‰²
    GREEN = '\033[92m'      # ç»¿è‰² - æˆåŠŸ/å®Œæˆ
    YELLOW = '\033[93m'     # é»„è‰² - è­¦å‘Š/é‡è¯•
    RED = '\033[91m'        # çº¢è‰² - é”™è¯¯
    GRAY = '\033[90m'       # ç°è‰² - ç­‰å¾…/æ— è¿›å±•
    BLUE = '\033[94m'       # è“è‰² - ä¿¡æ¯
    CYAN = '\033[96m'       # é’è‰² - è¿›åº¦
    MAGENTA = '\033[95m'    # å“çº¢ - ç‰¹æ®Šä¿¡æ¯

    # æ ·å¼
    BOLD = '\033[1m'        # ç²—ä½“
    RESET = '\033[0m'       # é‡ç½®æ‰€æœ‰æ ·å¼

    @staticmethod
    def strip(text):
        """ç§»é™¤æ–‡æœ¬ä¸­çš„é¢œè‰²ä»£ç ï¼ˆç”¨äºå†™å…¥æ—¥å¿—æ–‡ä»¶ï¼‰"""
        import re
        ansi_escape = re.compile(r'\033\[[0-9;]*m')
        return ansi_escape.sub('', text)

# åŠ è½½ç¯å¢ƒå˜é‡
load_dotenv()

# åŠ è½½YAMLé…ç½®
CONFIG_FILE = Path(__file__).parent.parent / 'config.yaml'
try:
    with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
        CONFIG = yaml.safe_load(f)
except FileNotFoundError:
    print(f"âš ï¸ è­¦å‘Š: é…ç½®æ–‡ä»¶ {CONFIG_FILE} ä¸å­˜åœ¨ï¼Œä½¿ç”¨é»˜è®¤é…ç½®")
    CONFIG = {}

# APIå¯†é’¥é…ç½®ï¼ˆä¼˜å…ˆä½¿ç”¨ç¯å¢ƒå˜é‡ï¼Œå…¶æ¬¡ä½¿ç”¨é…ç½®æ–‡ä»¶ï¼‰
DEEPSEEK_API_KEY = os.getenv('DeepSeek_API_KEY') or CONFIG.get('api', {}).get('deepseek_key', '')
WAVESPEED_API_KEY = os.getenv('Wavespeed_API_KEY') or CONFIG.get('api', {}).get('wavespeed_key', '')

# åˆå§‹åŒ–APIé™æµå™¨
rate_limits = CONFIG.get('rate_limits', {})

deepseek_limiter = RateLimiter(
    max_requests_per_minute=rate_limits.get('deepseek', {}).get('max_requests_per_minute'),
    max_requests_per_day=rate_limits.get('deepseek', {}).get('max_requests_per_day'),
    name="DeepSeek"
)

image_limiter = RateLimiter(
    max_requests_per_minute=rate_limits.get('image_generation', {}).get('max_requests_per_minute'),
    max_requests_per_day=rate_limits.get('image_generation', {}).get('max_requests_per_day'),
    name="å›¾åƒç”Ÿæˆ"
)

video_limiter = RateLimiter(
    max_requests_per_minute=rate_limits.get('video_generation', {}).get('max_requests_per_minute'),
    max_requests_per_day=rate_limits.get('video_generation', {}).get('max_requests_per_day'),
    name="è§†é¢‘ç”Ÿæˆ"
)

# è¾“å‡ºç›®å½•åŸºç¡€è·¯å¾„
OUTPUT_BASE = Path(CONFIG.get('workflow', {}).get('output_base', './output'))

# å·¥ä½œç›®å½•å’Œæ—¥å¿—æ–‡ä»¶å°†åœ¨ main() ä¸­æ ¹æ®å‘½ä»¤è¡Œå‚æ•°åˆå§‹åŒ–
WORK_DIR = None
LOG_FILE = None
RUN_TIMESTAMP = None

# ============================================================
# è‡ªå®šä¹‰å¼‚å¸¸ç±»
# ============================================================
class VideoGenerationError(Exception):
    """è§†é¢‘ç”ŸæˆåŸºç¡€å¼‚å¸¸"""
    pass

class APIError(VideoGenerationError):
    """APIè°ƒç”¨é”™è¯¯ï¼ˆå¯é‡è¯•ï¼‰"""
    def __init__(self, message, retry_after=None):
        super().__init__(message)
        self.retry_after = retry_after

class TaskFailedError(VideoGenerationError):
    """ä»»åŠ¡æ‰§è¡Œå¤±è´¥ï¼ˆä¸åº”é‡è¯•ï¼‰"""
    pass

class ConfigError(VideoGenerationError):
    """é…ç½®é”™è¯¯"""
    pass

# ============================================================
# è§†è§‰é£æ ¼æ¨¡æ¿ç³»ç»Ÿï¼ˆä»é…ç½®æ–‡ä»¶åŠ è½½ï¼‰
# ============================================================
# ä»YAMLé…ç½®æ–‡ä»¶åŠ è½½è§†è§‰é£æ ¼
STYLE_TEMPLATES = CONFIG.get('visual_styles', {})

# ============================================================
# ç”¨æˆ·å‹å¥½çš„æ•°å­—æ˜ å°„é…ç½®ï¼ˆç”¨äºconfig.tomlï¼‰
# ============================================================
# é£æ ¼æ•°å­—æ˜ å°„ï¼ˆæŒ‰yamlä¸­çš„é¡ºåºï¼Œä¿æŒç¨³å®šï¼‰
STYLE_NUMBER_MAP = {
    1: 'tech_product',
    2: 'luxury_fashion',
    3: 'minimalist_brand',
    4: 'realistic_3d',
    5: 'cinematic',
    6: 'technology',
    7: 'cyberpunk',
    8: 'holographic',
    9: 'corporate_tech',
    10: 'data_visualization'
}

# åˆ†è¾¨ç‡æ•°å­—æ˜ å°„
RESOLUTION_NUMBER_MAP = {
    1: '480p',
    2: '720p',
    3: '1080p'
}

# å¸ƒå°”å€¼æ•°å­—æ˜ å°„ï¼ˆé€šç”¨ï¼‰
BOOL_NUMBER_MAP = {
    0: False,
    1: True
}

# å­—å¹•ä½ç½®æ•°å­—æ˜ å°„
POSITION_NUMBER_MAP = {
    1: 'bottom',
    2: 'center',
    3: 'top'
}

# ============================================================
# æ¨¡å‹é€‰æ‹©é…ç½®ï¼ˆä»YAMLè¯»å–ï¼‰
# ============================================================
# å·¥ä½œæµé…ç½®
USE_DIRECT_T2V = CONFIG.get('workflow', {}).get('use_direct_t2v', False)

# å›¾åƒç”Ÿæˆæ¨¡å‹é…ç½®ï¼ˆä»YAMLè¯»å–ï¼‰
IMAGE_MODEL_CONFIG = CONFIG.get('models', {}).get('image', {}).get('available', {})
CURRENT_IMAGE_MODEL = CONFIG.get('models', {}).get('image', {}).get('current', 'seedream-v4')

# è§†é¢‘ç”Ÿæˆæ¨¡å‹é…ç½®ï¼ˆä»YAMLè¯»å–ï¼‰
VIDEO_MODEL_CONFIG = CONFIG.get('models', {}).get('video', {}).get('available', {})
CURRENT_VIDEO_MODEL = CONFIG.get('models', {}).get('video', {}).get('current', 'wan-2.5-i2v')

# å¦‚æœä½¿ç”¨ç›´æ¥T2Væ¨¡å¼ï¼Œè°ƒæ•´æ¨¡å‹é€‰æ‹©
if USE_DIRECT_T2V:
    CURRENT_IMAGE_MODEL = None
    # ç¡®ä¿è§†é¢‘æ¨¡å‹æ˜¯t2vç±»å‹
    if CURRENT_VIDEO_MODEL not in VIDEO_MODEL_CONFIG or VIDEO_MODEL_CONFIG[CURRENT_VIDEO_MODEL].get('type') != 't2v':
        CURRENT_VIDEO_MODEL = 'wan-2.6-t2v'

# å¹¶å‘é…ç½®ï¼ˆä»YAMLè¯»å–ï¼‰
MAX_CONCURRENT_WORKERS = CONFIG.get('workflow', {}).get('max_concurrent_workers', 2)

def log(message, level="INFO"):
    """å†™å…¥æ—¥å¿—å¹¶æ‰“å°ï¼ˆæ§åˆ¶å°å¸¦é¢œè‰²ï¼Œæ–‡ä»¶ä¸å¸¦é¢œè‰²ï¼‰"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    # æ ¹æ®levelå’Œæ¶ˆæ¯å†…å®¹é€‰æ‹©é¢œè‰²
    color = Colors.RESET
    if level == "ERROR" or "âŒ" in message or "é”™è¯¯" in message:
        color = Colors.RED
    elif level == "WARN" or "âš ï¸" in message or "è­¦å‘Š" in message or "é‡è¯•" in message:
        color = Colors.YELLOW
    elif level == "SUCCESS" or "âœ…" in message or "âœ“" in message or "å®Œæˆ" in message:
        color = Colors.GREEN
    elif "â³" in message or "ç­‰å¾…" in message or "â±ï¸" in message:
        color = Colors.GRAY
    elif "ğŸ“Š" in message or "è¿›åº¦" in message:
        color = Colors.CYAN
    elif level == "INFO":
        color = Colors.BLUE

    # æ§åˆ¶å°è¾“å‡ºï¼ˆå¸¦é¢œè‰²ï¼‰
    colored_message = f"{color}[{timestamp}] [{level}] {message}{Colors.RESET}"
    print(colored_message)
    sys.stdout.flush()

    # å†™å…¥æ—¥å¿—æ–‡ä»¶ï¼ˆä¸å¸¦é¢œè‰²ï¼‰
    plain_message = f"[{timestamp}] [{level}] {Colors.strip(message)}"
    with open(LOG_FILE, 'a', encoding='utf-8') as f:
        f.write(plain_message + '\n')


def get_video_duration_seconds(video_path):
    """è·å–è§†é¢‘æ—¶é•¿ï¼ˆç§’ï¼‰ï¼Œä¼˜å…ˆä½¿ç”¨MoviePyï¼Œå¤±è´¥åˆ™å›é€€åˆ°ffprobe"""
    try:
        from moviepy import VideoFileClip
        clip = VideoFileClip(str(video_path))
        duration = clip.duration
        clip.close()
        return float(duration or 0.0)
    except Exception:
        try:
            result = subprocess.run(
                [
                    "ffprobe", "-v", "error",
                    "-show_entries", "format=duration",
                    "-of", "default=noprint_wrappers=1:nokey=1",
                    str(video_path)
                ],
                capture_output=True,
                text=True,
                check=True
            )
            return float(result.stdout.strip())
        except Exception:
            return 0.0


def speedup_audio_file(input_path, output_path, speed_factor):
    """ä½¿ç”¨ffmpegåŠ é€ŸéŸ³é¢‘ï¼ˆatempoæ”¯æŒ0.5-2.0ï¼Œå·²é™åˆ¶ä¸º<=1.8ï¼‰"""
    if speed_factor <= 0:
        return False

    try:
        subprocess.run(
            [
                "ffmpeg", "-y",
                "-i", str(input_path),
                "-filter:a", f"atempo={speed_factor}",
                "-vn",
                str(output_path)
            ],
            check=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        return True
    except Exception as e:
        log(f"âš ï¸  éŸ³é¢‘å€é€Ÿå¤„ç†å¤±è´¥: {e}", "WARN")
        return False


def _format_srt_time(seconds: float) -> str:
    """æ ¼å¼åŒ–ç§’ä¸ºSRTæ—¶é—´æˆ³"""
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    milliseconds = int((seconds % 1) * 1000)
    return f"{hours:02d}:{minutes:02d}:{secs:02d},{milliseconds:03d}"


def rescale_srt_timestamps(input_srt, output_srt, scale: float):
    """æŒ‰æ¯”ä¾‹ç¼©æ”¾SRTæ—¶é—´è½´"""
    import re
    time_pattern = re.compile(r"(\d{2}:\d{2}:\d{2},\d{3}) --> (\d{2}:\d{2}:\d{2},\d{3})")

    def to_seconds(ts: str) -> float:
        h, m, rest = ts.split(":")
        s, ms = rest.split(",")
        return int(h) * 3600 + int(m) * 60 + int(s) + int(ms) / 1000.0

    lines = []
    with open(input_srt, "r", encoding="utf-8") as f:
        for line in f:
            match = time_pattern.search(line)
            if match:
                start = to_seconds(match.group(1)) * scale
                end = to_seconds(match.group(2)) * scale
                lines.append(f"{_format_srt_time(start)} --> {_format_srt_time(end)}\n")
            else:
                lines.append(line)

    with open(output_srt, "w", encoding="utf-8") as f:
        f.writelines(lines)


def write_srt_from_submaker(sub_maker, output_file):
    """å°†SubMakerç”Ÿæˆçš„å­—å¹•å†™å…¥SRT"""
    if not sub_maker:
        return False
    try:
        Path(output_file).parent.mkdir(parents=True, exist_ok=True)
        srt_content = sub_maker.get_srt()
        with open(output_file, "w", encoding="utf-8") as f:
            f.write(srt_content)
        return True
    except Exception as e:
        log(f"âš ï¸  å†™å…¥SRTå¤±è´¥: {e}", "WARN")
        return False


def generate_global_narration(shots_data, video_durations):
    """ä¸ºæ•´ç‰‡ç”Ÿæˆä¸€æ®µåˆ†å¥æ—ç™½ï¼Œæ¯å¥å¯¹åº”ä¸€ä¸ªé•œå¤´

    ä¼˜å…ˆä½¿ç”¨å·²ç”Ÿæˆçš„æ—ç™½ï¼ˆé˜¶æ®µ2ï¼‰ï¼Œé¿å…é‡å¤ç”Ÿæˆ
    """
    sentences = []

    # ä¼˜å…ˆä½¿ç”¨é˜¶æ®µ2å·²ç”Ÿæˆçš„æ—ç™½
    for shot in shots_data['shots']:
        narration = shot.get('narration', '').strip()
        if narration:
            sentences.append(narration)
        else:
            # æ²¡æœ‰æ—ç™½æ—¶ä½¿ç”¨æ‘˜è¦ä½œä¸ºå›é€€
            text = shot.get('summary_cn', '') or shot.get('description', '')
            sentences.append(text.strip()[:50])

    log(f"   âœ“ ä½¿ç”¨å·²ç”Ÿæˆçš„æ—ç™½ï¼ˆæ¥è‡ªé˜¶æ®µ2åˆ†é•œè„šæœ¬ï¼‰")
    return sentences



# ============================================================
# æˆæœ¬è®¡ç®—è¾…åŠ©å‡½æ•°
# ============================================================
def get_video_cost(model_name, resolution="720p"):
    """è·å–è§†é¢‘ç”Ÿæˆçš„æˆæœ¬ï¼ˆæŒ‰åˆ†è¾¨ç‡ï¼‰

    Args:
        model_name: æ¨¡å‹åç§°
        resolution: åˆ†è¾¨ç‡ï¼ˆ480p/720p/1080pï¼‰

    Returns:
        float: æˆæœ¬ï¼ˆç¾å…ƒï¼‰
    """
    model_config = VIDEO_MODEL_CONFIG.get(model_name, {})

    # ä¼˜å…ˆä½¿ç”¨åˆ†è¾¨ç‡å®šä»·
    cost_by_resolution = model_config.get('cost_by_resolution', {})
    if resolution in cost_by_resolution:
        return cost_by_resolution[resolution]

    # å›é€€åˆ°åŸºç¡€ä»·æ ¼
    return model_config.get('cost', 0.30)

# ============================================================
# ä½™é¢æŸ¥è¯¢åŠŸèƒ½
# ============================================================
def get_wavespeed_balance():
    """æŸ¥è¯¢ WavespeedAI è´¦æˆ·ä½™é¢

    Returns:
        float: ä½™é¢ï¼ˆç¾å…ƒï¼‰ï¼Œå¤±è´¥è¿”å› None
    """
    try:
        url = "https://api.wavespeed.ai/api/v3/balance"
        headers = {
            "Authorization": f"Bearer {WAVESPEED_API_KEY}"
        }

        response = requests.get(url, headers=headers, timeout=10)
        response.raise_for_status()

        result = response.json()
        # APIè¿”å›æ ¼å¼: {"code": 200, "message": "success", "data": {"balance": 93.54}}
        # æˆ–è€…ç›´æ¥: {"balance": 10.5} æˆ– {"credit": 10.5}
        if 'data' in result and isinstance(result['data'], dict):
            # åµŒå¥—æ ¼å¼
            data = result['data']
            balance = data.get('balance') or data.get('credit') or data.get('amount', 0)
        else:
            # ç›´æ¥æ ¼å¼
            balance = result.get('balance') or result.get('credit') or result.get('amount', 0)
        return float(balance)

    except requests.exceptions.Timeout:
        log("âš ï¸  æŸ¥è¯¢ä½™é¢è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥", "WARN")
        return None
    except requests.exceptions.RequestException as e:
        log(f"âš ï¸  æŸ¥è¯¢ä½™é¢å¤±è´¥: {str(e)}", "WARN")
        return None
    except Exception as e:
        log(f"âš ï¸  è§£æä½™é¢æ•°æ®å¤±è´¥: {str(e)}", "WARN")
        return None

def display_balance(before_balance=None, after_balance=None, cost=None, operation="APIè°ƒç”¨"):
    """æ˜¾ç¤ºä½™é¢ä¿¡æ¯

    Args:
        before_balance: è°ƒç”¨å‰ä½™é¢
        after_balance: è°ƒç”¨åä½™é¢
        cost: APIè°ƒç”¨æˆæœ¬
        operation: æ“ä½œæè¿°
    """
    if after_balance is None:
        return

    print()
    print("=" * 60)
    print(f"ğŸ’° è´¦æˆ·ä½™é¢ä¿¡æ¯ - {operation}")
    print("-" * 60)

    if before_balance is not None and cost is not None:
        actual_cost = before_balance - after_balance
        print(f"   è°ƒç”¨å‰ä½™é¢: ${before_balance:.4f}")
        print(f"   é¢„è®¡æˆæœ¬:   ${cost:.4f}")
        print(f"   å®é™…æˆæœ¬:   ${actual_cost:.4f}")
        print(f"   è°ƒç”¨åä½™é¢: ${after_balance:.4f}")

        # å¦‚æœå®é™…æˆæœ¬ä¸é¢„è®¡ä¸ç¬¦ï¼Œæ˜¾ç¤ºè­¦å‘Š
        if abs(actual_cost - cost) > 0.001:
            print(f"   âš ï¸  å®é™…æˆæœ¬ä¸é¢„è®¡ä¸ç¬¦ï¼Œå·®å¼‚: ${abs(actual_cost - cost):.4f}")
    else:
        print(f"   å½“å‰ä½™é¢: ${after_balance:.4f}")

    print("=" * 60)
    print()

def print_welcome():
    """æ˜¾ç¤ºæ¬¢è¿ç•Œé¢"""
    print("=" * 60)
    print("ğŸ¬ AIè§†é¢‘ç”Ÿæˆç³»ç»Ÿ v2.0ï¼ˆæ•…äº‹åŒ–å¢å¼ºç‰ˆï¼‰")
    print("=" * 60)
    print()

def select_style():
    """é€‰æ‹©è§†è§‰é£æ ¼"""
    print("ğŸ“ è¯·é€‰æ‹©è§†è§‰é£æ ¼ï¼š")
    print()

    styles = list(STYLE_TEMPLATES.items())
    for i, (key, style) in enumerate(styles, 1):
        print(f"  {i}. {style['name']}")

    print()

    while True:
        try:
            # åŠ¨æ€è·å–ç¬¬ä¸€ä¸ªé£æ ¼ä½œä¸ºé»˜è®¤å€¼
            default_style_key = styles[0][0]
            default_style_name = styles[0][1]['name']
            choice = input(f"è¯·è¾“å…¥ç¼–å· (1-{len(styles)}ï¼Œé»˜è®¤1-{default_style_name}): ").strip()
            if not choice:
                return default_style_key

            choice_num = int(choice)
            if 1 <= choice_num <= len(styles):
                selected_key = styles[choice_num - 1][0]
                selected_name = styles[choice_num - 1][1]['name']
                print(f"âœ… å·²é€‰æ‹©: {selected_name}\n")
                return selected_key
            else:
                print(f"âŒ è¯·è¾“å…¥1-{len(styles)}ä¹‹é—´çš„æ•°å­—")
        except ValueError:
            print("âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—")

def input_number(prompt, default, min_val, max_val):
    """è¾“å…¥æ•°å­—ï¼Œå¸¦éªŒè¯"""
    while True:
        try:
            user_input = input(f"{prompt} ({min_val}-{max_val}ï¼Œé»˜è®¤{default}): ").strip()
            if not user_input:
                print(f"âœ… ä½¿ç”¨é»˜è®¤å€¼: {default}\n")
                return default

            value = int(user_input)
            if min_val <= value <= max_val:
                print(f"âœ… å·²è®¾ç½®: {value}\n")
                return value
            else:
                print(f"{Colors.RED}âŒ è¯·è¾“å…¥{min_val}-{max_val}ä¹‹é—´çš„æ•°å­—{Colors.RESET}")
        except ValueError:
            print(f"{Colors.RED}âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—{Colors.RESET}")

def load_config_from_toml(config_path='config.toml'):
    """ä»TOMLé…ç½®æ–‡ä»¶åŠ è½½é…ç½®

    Args:
        config_path: é…ç½®æ–‡ä»¶è·¯å¾„ï¼Œé»˜è®¤ä¸º config.toml

    Returns:
        dict: é…ç½®å­—å…¸ï¼Œå¦‚æœåŠ è½½å¤±è´¥è¿”å› None
    """
    # å¦‚æœæ˜¯ç›¸å¯¹è·¯å¾„ï¼Œç›¸å¯¹äºé¡¹ç›®æ ¹ç›®å½•ï¼ˆè„šæœ¬æ‰€åœ¨ç›®å½•çš„çˆ¶ç›®å½•ï¼‰
    config_file = Path(config_path)
    if not config_file.is_absolute():
        # è·å–é¡¹ç›®æ ¹ç›®å½•ï¼ˆpyè„šæœ¬æ‰€åœ¨ç›®å½•çš„çˆ¶ç›®å½•ï¼‰
        project_root = Path(__file__).parent.parent
        config_file = project_root / config_path

    if not config_file.exists():
        return None

    try:
        config_data = load_toml(str(config_file))  # è½¬æ¢ä¸ºå­—ç¬¦ä¸²è·¯å¾„
        print(f"\nâœ… å·²ä» {config_path} åŠ è½½é…ç½®\n")

        # éªŒè¯å¿…éœ€å­—æ®µ
        if 'video' not in config_data:
            print("âŒ é…ç½®æ–‡ä»¶ç¼ºå°‘ [video] éƒ¨åˆ†")
            return None

        video = config_data['video']
        required_fields = ['topic', 'style', 'shot_count', 'shot_duration', 'resolution']
        for field in required_fields:
            if field not in video:
                print(f"âŒ é…ç½®æ–‡ä»¶ç¼ºå°‘å¿…éœ€å­—æ®µ: video.{field}")
                return None

        # ========== æ•°å­—æ˜ å°„è½¬æ¢ï¼ˆç”¨æˆ·å‹å¥½é…ç½®ï¼‰ ==========
        # è½¬æ¢é£æ ¼ï¼šæ”¯æŒæ•°å­—ï¼ˆ1-10ï¼‰æˆ–å­—ç¬¦ä¸²ï¼ˆtech_productç­‰ï¼‰
        if isinstance(video['style'], int):
            if video['style'] in STYLE_NUMBER_MAP:
                original_num = video['style']
                video['style'] = STYLE_NUMBER_MAP[video['style']]
                print(f"   ğŸ”¢ é£æ ¼æ•°å­— {original_num} â†’ {video['style']}")
            else:
                print(f"âŒ æ— æ•ˆçš„é£æ ¼ç¼–å·: {video['style']}")
                print(f"   å¯é€‰ç¼–å·: 1-{len(STYLE_NUMBER_MAP)} (1=ç§‘æŠ€äº§å“, 2=æ—¶å°šå¥¢å...)")
                return None

        # è½¬æ¢åˆ†è¾¨ç‡ï¼šæ”¯æŒæ•°å­—ï¼ˆ1-3ï¼‰æˆ–å­—ç¬¦ä¸²ï¼ˆ480pç­‰ï¼‰
        if isinstance(video['resolution'], int):
            if video['resolution'] in RESOLUTION_NUMBER_MAP:
                original_num = video['resolution']
                video['resolution'] = RESOLUTION_NUMBER_MAP[video['resolution']]
                print(f"   ğŸ”¢ åˆ†è¾¨ç‡æ•°å­— {original_num} â†’ {video['resolution']}")
            else:
                print(f"âŒ æ— æ•ˆçš„åˆ†è¾¨ç‡ç¼–å·: {video['resolution']}")
                print(f"   å¯é€‰ç¼–å·: 1=480p, 2=720p, 3=1080p")
                return None

        # éªŒè¯é£æ ¼æ˜¯å¦æœ‰æ•ˆ
        if video['style'] not in STYLE_TEMPLATES:
            print(f"âŒ æ— æ•ˆçš„è§†è§‰é£æ ¼: {video['style']}")
            print(f"   å¯é€‰å€¼: {', '.join(STYLE_TEMPLATES.keys())}")
            return None

        # éªŒè¯æ•°å€¼èŒƒå›´
        if not (2 <= video['shot_count'] <= 10):
            print(f"âŒ é•œå¤´æ•°é‡å¿…é¡»åœ¨ 2-10 ä¹‹é—´ï¼Œå½“å‰å€¼: {video['shot_count']}")
            return None

        if not (3 <= video['shot_duration'] <= 5):
            print(f"âŒ æ¯é•œå¤´æ—¶é•¿å¿…é¡»åœ¨ 3-5ç§’ ä¹‹é—´ï¼Œå½“å‰å€¼: {video['shot_duration']}")
            return None

        if video['resolution'] not in ['480p', '720p', '1080p']:
            print(f"âŒ æ— æ•ˆçš„åˆ†è¾¨ç‡: {video['resolution']}")
            print(f"   å¯é€‰å€¼: 480p, 720p, 1080p")
            return None

        # æ„å»ºé…ç½®å­—å…¸
        user_config = {
            'topic': video['topic'],
            'style': video['style'],
            'shot_count': video['shot_count'],
            'shot_duration': video['shot_duration'],
            'resolution': video['resolution'],
            'timestamp': RUN_TIMESTAMP
        }

        # å¤„ç†ä¸»è§’é…ç½®
        character = config_data.get('character', {})
        # è½¬æ¢å¸ƒå°”å€¼ï¼šæ”¯æŒæ•°å­—ï¼ˆ0/1ï¼‰æˆ–å¸ƒå°”å€¼ï¼ˆtrue/falseï¼‰
        if 'enabled' in character and isinstance(character['enabled'], int):
            character['enabled'] = BOOL_NUMBER_MAP.get(character['enabled'], False)

        if character.get('enabled', False):
            # æ£€æŸ¥æ˜¯å¦æœ‰å›¾ç‰‡æˆ–æè¿°
            has_image = character.get('character_image')
            has_description = character.get('description', '').strip()

            # å¦‚æœéƒ½æ²¡æœ‰ï¼Œæ£€æŸ¥é»˜è®¤å›¾ç‰‡ï¼ˆä»é…ç½®æ–‡ä»¶è¯»å–ï¼‰
            if not has_image and not has_description:
                default_image = character.get('default_character_image', './resource/pic/mai.jpg')
                # å¦‚æœæ˜¯ URLï¼Œç›´æ¥ä½¿ç”¨ï¼›å¦‚æœæ˜¯æœ¬åœ°æ–‡ä»¶ï¼Œæ£€æŸ¥æ˜¯å¦å­˜åœ¨
                if default_image.startswith(('http://', 'https://')):
                    print(f"   å°†ä½¿ç”¨é»˜è®¤ä¸»è§’å‚è€ƒå›¾ï¼ˆURLï¼‰: {default_image}")
                    has_image = default_image
                elif Path(default_image).exists():
                    print(f"   å°†ä½¿ç”¨é»˜è®¤ä¸»è§’å‚è€ƒå›¾ï¼ˆæœ¬åœ°ï¼‰: {default_image}")
                    has_image = default_image
                else:
                    print("âŒ å¯ç”¨ä¸»è§’ä¸€è‡´æ€§æ—¶å¿…é¡»æä¾› description æˆ– character_image")
                    print(f"   æˆ–ç¡®ä¿é»˜è®¤å›¾ç‰‡å­˜åœ¨: {default_image}")
                    return None

            user_config['character'] = {
                'enabled': True,
                'description': character.get('description', 'ä¸»è§’è§’è‰²'),
                'character_image': has_image if has_image else character.get('character_image'),
                'reference': None,
                'dna': None
            }
        else:
            user_config['character'] = {'enabled': False}

        # å¤„ç†å“ç‰Œé…ç½®
        brand = config_data.get('brand', {})
        # è½¬æ¢å¸ƒå°”å€¼ï¼šæ”¯æŒæ•°å­—ï¼ˆ0/1ï¼‰æˆ–å¸ƒå°”å€¼ï¼ˆtrue/falseï¼‰
        if 'enabled' in brand and isinstance(brand['enabled'], int):
            brand['enabled'] = BOOL_NUMBER_MAP.get(brand['enabled'], False)

        if brand.get('enabled', False):
            if not brand.get('name', '').strip():
                print("âŒ å¯ç”¨å“ç‰Œlogoæ—¶å¿…é¡»æä¾› name")
                return None
            user_config['brand'] = {
                'enabled': True,
                'name': brand['name'],
                'logo_image': brand.get('logo_image'),
                'default_logo_image': brand.get('default_logo_image', './resource/logo/aka.jpg'),
                'description': brand.get('description', '')
            }
        else:
            user_config['brand'] = {'enabled': False}

        # å¤„ç†å­—å¹•é…ç½®ï¼ˆå¯é€‰ï¼‰
        subtitle = config_data.get('subtitle', {})
        if subtitle:
            # è½¬æ¢å­—å¹•ä½ç½®ï¼šæ”¯æŒæ•°å­—ï¼ˆ1-3ï¼‰æˆ–å­—ç¬¦ä¸²ï¼ˆbottomç­‰ï¼‰
            position = subtitle.get('position', 'bottom')
            if isinstance(position, int):
                position = POSITION_NUMBER_MAP.get(position, 'bottom')

            user_config['subtitle'] = {
                'font_size': subtitle.get('font_size', 24),
                'font_color': subtitle.get('font_color', 'white'),
                'outline_color': subtitle.get('outline_color', 'black'),
                'outline_width': subtitle.get('outline_width', 2),
                'position': position
            }

        # å¤„ç†å¹¶å‘é…ç½®
        workflow = config_data.get('workflow', {})
        concurrent_workers = workflow.get('concurrent_workers', 2)

        # è½¬æ¢è‡ªåŠ¨ç¡®è®¤ï¼šæ”¯æŒæ•°å­—ï¼ˆ0/1ï¼‰æˆ–å¸ƒå°”å€¼ï¼ˆtrue/falseï¼‰
        auto_confirm = workflow.get('auto_confirm', True)
        if isinstance(auto_confirm, int):
            auto_confirm = BOOL_NUMBER_MAP.get(auto_confirm, True)

        if not (1 <= concurrent_workers <= 9):
            print(f"âŒ å¹¶å‘çº¿ç¨‹æ•°å¿…é¡»åœ¨ 1-9 ä¹‹é—´ï¼Œå½“å‰å€¼: {concurrent_workers}")
            return None

        # æ˜¾ç¤ºé…ç½®æ‘˜è¦
        print("=" * 60)
        print("ğŸ“‹ é…ç½®æ‘˜è¦")
        print("=" * 60)
        print(f"  ä¸»é¢˜: {user_config['topic']}")
        print(f"  é£æ ¼: {STYLE_TEMPLATES[user_config['style']]['name']}")
        print(f"  é•œå¤´æ•°: {user_config['shot_count']}ä¸ª")
        print(f"  å•é•œå¤´æ—¶é•¿: {user_config['shot_duration']}ç§’")
        print(f"  åˆ†è¾¨ç‡: {user_config['resolution']}")
        if user_config['character']['enabled']:
            print(f"  ä¸»è§’: {user_config['character']['description'][:40]}...")
            if user_config['character'].get('character_image'):
                print(f"  ä¸»è§’å‚è€ƒå›¾: {user_config['character']['character_image']}")
        if user_config['brand']['enabled']:
            print(f"  å“ç‰Œ: {user_config['brand']['name']} logo")
            if user_config['brand'].get('logo_image'):
                print(f"  Logoå‚è€ƒå›¾: {user_config['brand']['logo_image']}")
        print(f"  å¹¶å‘çº¿ç¨‹æ•°: {concurrent_workers}")
        print(f"  é¢„è®¡æ€»æ—¶é•¿: {user_config['shot_count'] * 3}ç§’ï¼ˆæ¯é•œå¤´å‰ªè¾‘ä¸º3ç§’ï¼‰")
        print("=" * 60)

        # è¯¢é—®ç¡®è®¤ï¼ˆå¦‚æœæœªè®¾ç½®è‡ªåŠ¨ç¡®è®¤ï¼‰
        if not auto_confirm:
            confirm = input("\nç¡®è®¤å¼€å§‹ç”Ÿæˆ? (y/nï¼Œé»˜è®¤y): ").strip().lower()
            if confirm and confirm != 'y':
                print("âŒ å·²å–æ¶ˆ")
                sys.exit(0)

        print("âœ… å¼€å§‹ç”Ÿæˆ...\n")

        return user_config, concurrent_workers

    except Exception as e:
        # æ•è·æ‰€æœ‰TOMLè§£æé”™è¯¯å’Œå…¶ä»–å¼‚å¸¸
        if 'TOML' in str(type(e).__name__) or 'toml' in str(type(e).__name__).lower():
            print(f"{Colors.RED}âŒ TOMLé…ç½®æ–‡ä»¶è§£æé”™è¯¯: {e}{Colors.RESET}")
        else:
            print(f"{Colors.RED}âŒ åŠ è½½é…ç½®æ–‡ä»¶æ—¶å‡ºé”™: {e}{Colors.RESET}")
        return None

def interactive_setup():
    """äº¤äº’å¼é…ç½®å‘å¯¼"""
    print_welcome()

    # 1. è¾“å…¥ä¸»é¢˜
    print("ğŸ’¡ è§†é¢‘ä¸»é¢˜")
    topic = input("è¯·è¾“å…¥è§†é¢‘ä¸»é¢˜ï¼ˆå¦‚ï¼šAkamaiæ¨å‡ºAIæ¨ç†äº‘ï¼‰: ").strip()
    while not topic:
        topic = input("âš ï¸  ä¸»é¢˜ä¸èƒ½ä¸ºç©ºï¼Œè¯·é‡æ–°è¾“å…¥: ").strip()
    print(f"âœ… ä¸»é¢˜: {topic}\n")

    # 2. é€‰æ‹©é£æ ¼
    style = select_style()

    # 3. é…ç½®é•œå¤´æ•°
    shot_count = input_number("ğŸ“¹ é•œå¤´æ•°é‡", default=2, min_val=2, max_val=10)

    # 4. é…ç½®æ—¶é•¿
    duration = input_number("â±ï¸  æ¯é•œå¤´æ—¶é•¿(ç§’)", default=5, min_val=3, max_val=5)

    # 5. é€‰æ‹©åˆ†è¾¨ç‡
    print("ğŸ“º è§†é¢‘åˆ†è¾¨ç‡")
    print("  1. 480p (è¾ƒå¿«ï¼Œæˆæœ¬ä½)")
    print("  2. 720p (æ¨èï¼Œå¹³è¡¡)")
    print("  3. 1080p (é«˜æ¸…ï¼Œè¾ƒæ…¢)")
    print()

    resolution_map = {
        1: "480p",
        2: "720p",
        3: "1080p"
    }

    while True:
        try:
            res_choice = input("è¯·é€‰æ‹©åˆ†è¾¨ç‡ (1-3ï¼Œé»˜è®¤1-480p): ").strip()
            if not res_choice:
                resolution = "480p"
                print(f"âœ… ä½¿ç”¨é»˜è®¤: {resolution}\n")
                break

            res_num = int(res_choice)
            if 1 <= res_num <= 3:
                resolution = resolution_map[res_num]
                print(f"âœ… å·²é€‰æ‹©: {resolution}\n")
                break
            else:
                print("âŒ è¯·è¾“å…¥1-3ä¹‹é—´çš„æ•°å­—")
        except ValueError:
            print("âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—")

    # 6. ä¸»è§’é…ç½®ï¼ˆä¸€è‡´æ€§ä¿éšœï¼‰
    print("=" * 60)
    print("ğŸ‘¤ ä¸»è§’ä¸€è‡´æ€§é…ç½®ï¼ˆå¯é€‰ï¼‰")
    print("=" * 60)
    print("æç¤ºï¼šå¦‚æœéœ€è¦æ‰€æœ‰é•œå¤´ä½¿ç”¨åŒä¸€ä¸ªä¸»è§’ï¼Œè¯·åœ¨æ­¤é…ç½®")
    print()

    character_config = {'enabled': False}

    has_character = input("æ˜¯å¦éœ€è¦å›ºå®šä¸»è§’å½¢è±¡? (y/nï¼Œé»˜è®¤n): ").strip().lower()
    if has_character == 'y':
        character_desc = input("è¯·è¯¦ç»†æè¿°ä¸»è§’å¤–è§‚ï¼ˆä¸­æ–‡ï¼‰: ").strip()
        while not character_desc:
            character_desc = input("âš ï¸  æè¿°ä¸èƒ½ä¸ºç©ºï¼Œè¯·é‡æ–°è¾“å…¥: ").strip()

        character_config = {
            'enabled': True,
            'description': character_desc,
            'reference': None,  # ç¨åç”Ÿæˆ
            'dna': None         # ç¨åç”Ÿæˆ
        }
        print(f"âœ… ä¸»è§’: {character_desc[:50]}...\n")
    else:
        print("â­ï¸  è·³è¿‡ä¸»è§’é…ç½®\n")

    # 7. å“ç‰Œé…ç½®ï¼ˆlogoå åŠ ï¼‰
    print("=" * 60)
    print("ğŸ¢ å“ç‰Œå…ƒç´ é…ç½®ï¼ˆå¯é€‰ï¼‰")
    print("=" * 60)
    print("æç¤ºï¼šç³»ç»Ÿä¼šåœ¨æ¯ä¸ªé•œå¤´å³ä¸‹è§’æ·»åŠ å“ç‰Œlogoæ°´å°")
    print()

    brand_config = {'enabled': False}

    has_brand = input("æ˜¯å¦éœ€è¦æ·»åŠ å“ç‰Œlogo? (y/nï¼Œé»˜è®¤y): ").strip().lower()
    if not has_brand or has_brand == 'y':
        brand_name = input("å“ç‰Œåç§°ï¼ˆå¦‚Akamaiï¼‰: ").strip()
        if brand_name:
            brand_config = {
                'enabled': True,
                'name': brand_name
            }
            print(f"âœ… å“ç‰Œ: {brand_name}\n")
        else:
            print("â­ï¸  å“ç‰Œåç§°ä¸ºç©ºï¼Œè·³è¿‡\n")
    else:
        print("â­ï¸  è·³è¿‡å“ç‰Œé…ç½®\n")

    # 8. ç¡®è®¤é…ç½®
    print("=" * 60)
    print("ğŸ“‹ é…ç½®ç¡®è®¤")
    print("=" * 60)
    print(f"  ä¸»é¢˜: {topic}")
    print(f"  é£æ ¼: {STYLE_TEMPLATES[style]['name']}")
    print(f"  é•œå¤´æ•°: {shot_count}ä¸ª")
    print(f"  å•é•œå¤´æ—¶é•¿: {duration}ç§’")
    print(f"  åˆ†è¾¨ç‡: {resolution}")
    if character_config['enabled']:
        print(f"  ä¸»è§’: {character_config['description'][:40]}...")
    if brand_config['enabled']:
        print(f"  å“ç‰Œ: {brand_config['name']} logo")
    print(f"  é¢„è®¡æ€»æ—¶é•¿: {shot_count * 3}ç§’ï¼ˆæ¯é•œå¤´å‰ªè¾‘ä¸º3ç§’ï¼‰")
    print("=" * 60)

    confirm = input("\nç¡®è®¤å¼€å§‹ç”Ÿæˆ? (y/nï¼Œé»˜è®¤y): ").strip().lower()
    if confirm and confirm != 'y':
        print("âŒ å·²å–æ¶ˆ")
        sys.exit(0)

    print("âœ… å¼€å§‹ç”Ÿæˆ...\n")

    return {
        'topic': topic,
        'style': style,
        'shot_count': shot_count,
        'shot_duration': duration,
        'resolution': resolution,
        'character': character_config,
        'brand': brand_config,
        'timestamp': RUN_TIMESTAMP
    }

def ask_concurrent_workers():
    """è¯¢é—®ç”¨æˆ·é€‰æ‹©å¹¶å‘çº¿ç¨‹æ•°

    Returns:
        int: ç”¨æˆ·é€‰æ‹©çš„å¹¶å‘çº¿ç¨‹æ•°ï¼ˆ3-9ï¼‰
    """
    print("\n" + "=" * 60)
    print("âš™ï¸  å¹¶å‘è®¾ç½®")
    print("=" * 60)
    print("è§†é¢‘ç”Ÿæˆæ”¯æŒå¹¶å‘åŠ é€Ÿï¼Œè¯·é€‰æ‹©å¹¶å‘çº¿ç¨‹æ•°ï¼š")
    print("  â€¢ 3çº¿ç¨‹ï¼ˆæ¨èï¼‰- ç¨³å®šå¯é ï¼Œæå°‘é™æµ")
    print("  â€¢ 5çº¿ç¨‹ - æ›´å¿«ï¼Œå¶å°”å¯èƒ½è§¦å‘é™æµ")
    print("  â€¢ 7-9çº¿ç¨‹ - æœ€å¿«ï¼Œé™æµé£é™©è¾ƒé«˜")
    print()

    while True:
        try:
            choice = input("è¯·è¾“å…¥å¹¶å‘çº¿ç¨‹æ•° [3-9ï¼Œé»˜è®¤3]: ").strip()

            # é»˜è®¤å€¼
            if not choice:
                return 3

            workers = int(choice)
            if 3 <= workers <= 9:
                print(f"\n{Colors.GREEN}âœ“ å·²è®¾ç½®å¹¶å‘çº¿ç¨‹æ•°: {workers}{Colors.RESET}")
                return workers
            else:
                print(f"{Colors.RED}âŒ è¯·è¾“å…¥3-9ä¹‹é—´çš„æ•°å­—{Colors.RESET}")
        except ValueError:
            print(f"{Colors.RED}âŒ æ— æ•ˆè¾“å…¥ï¼Œè¯·è¾“å…¥æ•°å­—{Colors.RESET}")
        except KeyboardInterrupt:
            print(f"\n\n{Colors.YELLOW}âš ï¸  ç”¨æˆ·å–æ¶ˆï¼Œä½¿ç”¨é»˜è®¤å€¼: 3{Colors.RESET}")
            return 3

def validate_config():
    """éªŒè¯é…ç½®å’Œç¯å¢ƒ

    Raises:
        ValueError: é…ç½®ç¼ºå¤±æˆ–æ— æ•ˆ
    """
    errors = []

    # æ£€æŸ¥APIå¯†é’¥
    if not DEEPSEEK_API_KEY:
        errors.append("ç¼ºå°‘ç¯å¢ƒå˜é‡ DeepSeek_API_KEY")
    elif len(DEEPSEEK_API_KEY) < 20:
        errors.append("DeepSeek_API_KEY æ ¼å¼å¯èƒ½æ— æ•ˆï¼ˆé•¿åº¦è¿‡çŸ­ï¼‰")

    if not WAVESPEED_API_KEY:
        errors.append("ç¼ºå°‘ç¯å¢ƒå˜é‡ Wavespeed_API_KEY")

    # æ£€æŸ¥æ¨¡å‹é…ç½®
    if not USE_DIRECT_T2V and CURRENT_IMAGE_MODEL not in IMAGE_MODEL_CONFIG:
        errors.append(f"æ— æ•ˆçš„å›¾åƒæ¨¡å‹: {CURRENT_IMAGE_MODEL}")

    if CURRENT_VIDEO_MODEL not in VIDEO_MODEL_CONFIG:
        errors.append(f"æ— æ•ˆçš„è§†é¢‘æ¨¡å‹: {CURRENT_VIDEO_MODEL}")

    # æ£€æŸ¥è¾“å‡ºç›®å½•æƒé™
    if not WORK_DIR.exists():
        try:
            WORK_DIR.mkdir(parents=True, exist_ok=True)
        except Exception as e:
            errors.append(f"æ— æ³•åˆ›å»ºè¾“å‡ºç›®å½• {WORK_DIR}: {e}")

    if not os.access(WORK_DIR, os.W_OK):
        errors.append(f"è¾“å‡ºç›®å½•ä¸å¯å†™: {WORK_DIR}")

    # æ£€æŸ¥å¿…éœ€çš„ä¾èµ–
    try:
        import imageio_ffmpeg
        ffmpeg_bin = imageio_ffmpeg.get_ffmpeg_exe()
        if not Path(ffmpeg_bin).exists():
            errors.append("FFmpeg ä¸å¯ç”¨")
    except Exception as e:
        errors.append(f"FFmpeg æ£€æŸ¥å¤±è´¥: {e}")

    if errors:
        error_msg = "âŒ é…ç½®éªŒè¯å¤±è´¥:\n" + "\n".join(f"  â€¢ {e}" for e in errors)
        raise ValueError(error_msg)

    print("âœ… é…ç½®éªŒè¯é€šè¿‡")

def smart_retry(max_attempts=3, backoff_factor=2, max_backoff=60):
    """æ™ºèƒ½é‡è¯•è£…é¥°å™¨ï¼Œä½¿ç”¨æŒ‡æ•°é€€é¿ç­–ç•¥

    Args:
        max_attempts: æœ€å¤§å°è¯•æ¬¡æ•°
        backoff_factor: é€€é¿å› å­
        max_backoff: æœ€å¤§é€€é¿æ—¶é—´ï¼ˆç§’ï¼‰
    """
    def decorator(func):
        def wrapper(*args, **kwargs):
            last_exception = None

            for attempt in range(1, max_attempts + 1):
                try:
                    return func(*args, **kwargs)

                except TaskFailedError:
                    # ä»»åŠ¡å¤±è´¥ï¼Œä¸é‡è¯•
                    raise

                except APIError as e:
                    # APIé”™è¯¯ï¼Œä½¿ç”¨è‡ªå®šä¹‰çš„é‡è¯•æ—¶é—´
                    last_exception = e
                    if attempt < max_attempts:
                        wait_time = e.retry_after or min(backoff_factor ** attempt, max_backoff)
                        log(f"   âš ï¸  APIé”™è¯¯ (å°è¯• {attempt}/{max_attempts}): {e}", "WARN")
                        log(f"   â° {wait_time}ç§’åé‡è¯•...")
                        time.sleep(wait_time)
                    else:
                        log(f"   âŒ APIé”™è¯¯ï¼Œå·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°", "ERROR")

                except requests.exceptions.RequestException as e:
                    # ç½‘ç»œé”™è¯¯ï¼Œä½¿ç”¨æŒ‡æ•°é€€é¿
                    last_exception = e
                    if attempt < max_attempts:
                        wait_time = min(backoff_factor ** attempt, max_backoff)
                        log(f"   âš ï¸  ç½‘ç»œé”™è¯¯ (å°è¯• {attempt}/{max_attempts}): {e}", "WARN")
                        log(f"   â° {wait_time}ç§’åé‡è¯•...")
                        time.sleep(wait_time)
                    else:
                        log(f"   âŒ ç½‘ç»œé”™è¯¯ï¼Œå·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°", "ERROR")

                except Exception as e:
                    # å…¶ä»–æœªçŸ¥é”™è¯¯ï¼Œä¸é‡è¯•
                    log(f"   âŒ æœªçŸ¥é”™è¯¯: {type(e).__name__}: {e}", "ERROR")
                    raise

            # æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥
            raise last_exception

        return wrapper
    return decorator

def load_checkpoint():
    """åŠ è½½æ£€æŸ¥ç‚¹æ–‡ä»¶

    Returns:
        dict: åŒ…å«å·²å®Œæˆé•œå¤´IDåˆ—è¡¨çš„å­—å…¸ï¼Œå¦‚æœæ–‡ä»¶ä¸å­˜åœ¨è¿”å›ç©ºå­—å…¸
    """
    checkpoint_file = WORK_DIR / '00_checkpoint.json'
    if checkpoint_file.exists():
        try:
            with open(checkpoint_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            log(f"âš ï¸  åŠ è½½æ£€æŸ¥ç‚¹å¤±è´¥: {e}ï¼Œå°†ä»å¤´å¼€å§‹", "WARN")
            return {'completed_shots': [], 'failed_shots': []}
    return {'completed_shots': [], 'failed_shots': []}

def save_checkpoint(checkpoint):
    """ä¿å­˜æ£€æŸ¥ç‚¹æ–‡ä»¶

    Args:
        checkpoint: dict, åŒ…å«completed_shotså’Œfailed_shotsåˆ—è¡¨
    """
    checkpoint_file = WORK_DIR / '00_checkpoint.json'
    checkpoint['last_update'] = datetime.now().isoformat()
    try:
        with open(checkpoint_file, 'w', encoding='utf-8') as f:
            json.dump(checkpoint, f, indent=2, ensure_ascii=False)
    except Exception as e:
        log(f"âš ï¸  ä¿å­˜æ£€æŸ¥ç‚¹å¤±è´¥: {e}", "WARN")

def find_latest_task_dir():
    """æŸ¥æ‰¾æœ€æ–°çš„ä»»åŠ¡ç›®å½•

    Returns:
        Path or None: æœ€æ–°çš„ä»»åŠ¡ç›®å½•ï¼Œå¦‚æœæ²¡æœ‰åˆ™è¿”å›None
    """
    if not OUTPUT_BASE.exists():
        return None

    # è·å–æ‰€æœ‰ aka-* ç›®å½•
    task_dirs = [d for d in OUTPUT_BASE.iterdir()
                 if d.is_dir() and d.name.startswith('aka-')]

    if not task_dirs:
        return None

    # æŒ‰åç§°æ’åºï¼ˆæ—¶é—´æˆ³æ ¼å¼ä¿è¯äº†å­—æ¯åº=æ—¶é—´åºï¼‰
    return sorted(task_dirs)[-1]

def check_task_completeness(task_dir):
    """æ£€æŸ¥ä»»åŠ¡å®Œæ•´æ€§

    Args:
        task_dir: Path, ä»»åŠ¡ç›®å½•

    Returns:
        dict: {
            'complete': bool,     # æ˜¯å¦å®Œæ•´
            'script': bool,       # æ˜¯å¦æœ‰è„šæœ¬
            'images': (int, int), # (å·²å®Œæˆæ•°, æ€»æ•°)
            'videos': (int, int), # (å·²å®Œæˆæ•°, æ€»æ•°)
            'final': bool         # æ˜¯å¦æœ‰æœ€ç»ˆè§†é¢‘
        }
    """
    result = {
        'complete': False,
        'script': False,
        'images': (0, 0),
        'videos': (0, 0),
        'final': False
    }

    # æ£€æŸ¥è„šæœ¬æ–‡ä»¶
    script_file = task_dir / '22_shots_script.json'
    if script_file.exists():
        result['script'] = True

        # è¯»å–é•œå¤´æ•°é‡
        try:
            with open(script_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
                shot_count = len(data.get('shots', []))

                # æ£€æŸ¥å›¾åƒ
                image_count = sum(1 for i in range(1, shot_count + 1)
                                if (task_dir / f'{30 + (i - 1):02d}_shot_{i:02d}_image.png').exists())
                result['images'] = (image_count, shot_count)

                # æ£€æŸ¥è§†é¢‘
                video_count = sum(1 for i in range(1, shot_count + 1)
                                if (task_dir / f'{50 + (i - 1):02d}_shot_{i:02d}.mp4').exists())
                result['videos'] = (video_count, shot_count)
        except Exception:
            pass

    # æ£€æŸ¥æœ€ç»ˆè§†é¢‘
    if (task_dir / '90_final.mp4').exists():
        result['final'] = True

    # åˆ¤æ–­æ˜¯å¦å®Œæ•´ï¼ˆæœ‰è„šæœ¬ä¸”æœ‰æœ€ç»ˆè§†é¢‘å³ä¸ºå®Œæ•´ï¼‰
    if result['script'] and result['final']:
        result['complete'] = True

    return result

def auto_resume_check():
    """è‡ªåŠ¨æ£€æŸ¥æ˜¯å¦éœ€è¦æ–­ç‚¹ç»§ç»­

    Returns:
        Path or None: å¦‚æœéœ€è¦ç»§ç»­ï¼Œè¿”å›ä»»åŠ¡ç›®å½•ï¼›å¦åˆ™è¿”å›None
    """
    latest_dir = find_latest_task_dir()

    if not latest_dir:
        print(f"{Colors.BLUE}âœ¨ æ²¡æœ‰æ£€æµ‹åˆ°ä¹‹å‰çš„ä»»åŠ¡ï¼Œå¼€å§‹æ–°ä»»åŠ¡{Colors.RESET}\n")
        return None

    completeness = check_task_completeness(latest_dir)

    if completeness['complete']:
        print(f"{Colors.GREEN}âœ… æœ€è¿‘çš„ä»»åŠ¡ {latest_dir.name} å·²å®Œæˆï¼Œå¼€å§‹æ–°ä»»åŠ¡{Colors.RESET}\n")
        return None

    # ä»»åŠ¡æœªå®Œæˆï¼Œæ˜¾ç¤ºè¯¦æƒ…
    print(f"\n{Colors.CYAN}ğŸ“‚ æ£€æµ‹åˆ°æœªå®Œæˆçš„ä»»åŠ¡: {latest_dir.name}{Colors.RESET}")
    print("â”€" * 60)

    if completeness['script']:
        print(f"{Colors.GREEN}   âœ“ æ•…äº‹è„šæœ¬å·²ç”Ÿæˆ{Colors.RESET}")
    else:
        print(f"{Colors.GRAY}   âœ— æ•…äº‹è„šæœ¬æœªç”Ÿæˆ{Colors.RESET}")

    if completeness['images'][1] > 0:
        img_done, img_total = completeness['images']
        if img_done == img_total:
            print(f"{Colors.GREEN}   âœ“ å›¾åƒ: {img_done}/{img_total} å·²å®Œæˆ{Colors.RESET}")
        elif img_done > 0:
            print(f"{Colors.YELLOW}   âš ï¸  å›¾åƒ: {img_done}/{img_total} å·²å®Œæˆ{Colors.RESET}")
        else:
            print(f"{Colors.GRAY}   âœ— å›¾åƒ: {img_done}/{img_total} å·²å®Œæˆ{Colors.RESET}")

    if completeness['videos'][1] > 0:
        vid_done, vid_total = completeness['videos']
        if vid_done == vid_total:
            print(f"{Colors.GREEN}   âœ“ è§†é¢‘: {vid_done}/{vid_total} å·²å®Œæˆ{Colors.RESET}")
        elif vid_done > 0:
            print(f"{Colors.YELLOW}   âš ï¸  è§†é¢‘: {vid_done}/{vid_total} å·²å®Œæˆ{Colors.RESET}")
        else:
            print(f"{Colors.GRAY}   âœ— è§†é¢‘: {vid_done}/{vid_total} å·²å®Œæˆ{Colors.RESET}")

    if completeness['final']:
        print(f"{Colors.GREEN}   âœ“ æœ€ç»ˆè§†é¢‘å·²ç”Ÿæˆ{Colors.RESET}")
    else:
        print(f"{Colors.GRAY}   âœ— æœ€ç»ˆè§†é¢‘æœªç”Ÿæˆ{Colors.RESET}")

    print("â”€" * 60)

    # è¯¢é—®ç”¨æˆ·
    try:
        response = input("\næ˜¯å¦ä»æ–­ç‚¹ç»§ç»­ï¼Ÿ(y/n) [é»˜è®¤: y]: ").strip().lower()
    except (EOFError, KeyboardInterrupt):
        print("\n\nâš ï¸  ç”¨æˆ·ä¸­æ–­")
        return None

    if response in ['', 'y', 'yes', 'æ˜¯']:
        return latest_dir
    else:
        print("âœ¨ å¼€å§‹æ–°ä»»åŠ¡\n")
        return None

def parse_api_response(response_json, context="APIè°ƒç”¨"):
    """è§£æAPIå“åº”ï¼Œç»Ÿä¸€å¤„ç†ä¸åŒæ ¼å¼

    Args:
        response_json: APIè¿”å›çš„JSONå¯¹è±¡
        context: è°ƒç”¨ä¸Šä¸‹æ–‡ï¼Œç”¨äºæ—¥å¿—

    Returns:
        dict: è§£æåçš„æ•°æ®å­—å…¸

    Raises:
        ValueError: å“åº”æ ¼å¼æ— æ•ˆ
    """
    # è°ƒè¯•ï¼šæ‰“å°åŸå§‹å“åº”ï¼ˆä»…åœ¨DEBUGæ¨¡å¼ï¼‰
    if os.getenv('DEBUG') == '1':
        log(f"   [DEBUG] {context} åŸå§‹å“åº”: {json.dumps(response_json, ensure_ascii=False)[:200]}...")

    # å¤„ç†åµŒå¥—æ ¼å¼ï¼š{"code": 200, "data": {...}}
    if 'code' in response_json:
        if response_json.get('code') != 200:
            error_msg = response_json.get('message', 'æœªçŸ¥é”™è¯¯')
            raise APIError(f"APIè¿”å›é”™è¯¯: {error_msg}")

        # è§£åŒ…dataå­—æ®µ
        if 'data' in response_json:
            return response_json['data']
        else:
            # æŸäº›APIåªæœ‰codeå’Œmessageï¼Œæ²¡æœ‰data
            return response_json

    # æ‰å¹³æ ¼å¼ï¼šç›´æ¥è¿”å›
    return response_json

def validate_task_id(task_id, context="ä»»åŠ¡"):
    """éªŒè¯ä»»åŠ¡IDæœ‰æ•ˆæ€§

    Args:
        task_id: ä»»åŠ¡ID
        context: ä¸Šä¸‹æ–‡æè¿°

    Raises:
        APIError: task_idæ— æ•ˆ
    """
    if not task_id or task_id == 'None' or not isinstance(task_id, str):
        raise APIError(f"{context}IDæ— æ•ˆ: {task_id}ï¼Œè¯·æ£€æŸ¥APIå“åº”æ ¼å¼")

def show_progress_bar(current, total, label="è¿›åº¦"):
    """æ˜¾ç¤ºè¿›åº¦ä¿¡æ¯ï¼ˆä¸ä½¿ç”¨\\rï¼Œç›´æ¥è¾“å‡ºï¼‰"""
    percent = int(current / total * 100)
    log(f"   {label}: {current}/{total} ({percent}%)")

# ============================================================
# ä¸€è‡´æ€§ä¿éšœç³»ç»Ÿï¼ˆConsistency Assurance Systemï¼‰
# ============================================================

def generate_character_reference(character_description_cn):
    """ç”Ÿæˆä¸»è§’å‚è€ƒå›¾ï¼ˆç”¨äºä¸€è‡´æ€§ä¿éšœï¼‰

    Args:
        character_description_cn: str, ç”¨æˆ·è¾“å…¥çš„ä¸­æ–‡è§’è‰²æè¿°

    Returns:
        str: ç”Ÿæˆçš„å‚è€ƒå›¾URL
    """
    log("")
    log("="*60)
    log("ğŸ‘¤ ç”Ÿæˆä¸»è§’å‚è€ƒå›¾")
    log("="*60)

    # ç¿»è¯‘ä¸ºè‹±æ–‡prompt
    translation_prompt = f"""è¯·å°†ä»¥ä¸‹ä¸­æ–‡è§’è‰²æè¿°ç¿»è¯‘æˆé€‚åˆAIå›¾åƒç”Ÿæˆçš„è‹±æ–‡promptï¼š

ä¸­æ–‡æè¿°ï¼š{character_description_cn}

è¦æ±‚ï¼š
1. ç¿»è¯‘æˆä¸“ä¸šçš„è‹±æ–‡prompt
2. æ·»åŠ å¿…è¦çš„è§†è§‰ç»†èŠ‚ï¼ˆå¦‚æè´¨ã€å…‰æ•ˆã€å§¿æ€ï¼‰
3. æ·»åŠ "character design sheet, front view, full body, white background"
4. 80-120è¯

åªè¿”å›è‹±æ–‡promptï¼Œä¸è¦å…¶ä»–å†…å®¹ã€‚
"""

    log("ğŸ“ ç¿»è¯‘è§’è‰²æè¿°ä¸ºè‹±æ–‡prompt...")

    url = "https://api.deepseek.com/v1/chat/completions"
    headers = {
        "Authorization": f"Bearer {DEEPSEEK_API_KEY}",
        "Content-Type": "application/json"
    }

    payload = {
        "model": "deepseek-chat",
        "messages": [{"role": "user", "content": translation_prompt}],
        "temperature": 0.3  # ä½æ¸©åº¦ä¿è¯å‡†ç¡®ç¿»è¯‘
    }

    try:
        # APIé™æµæ§åˆ¶
        deepseek_limiter.acquire()
        response = requests.post(url, headers=headers, json=payload, timeout=60)
        response.raise_for_status()
        result = response.json()
        english_prompt = result['choices'][0]['message']['content'].strip()

        # ç§»é™¤å¯èƒ½çš„å¼•å·
        if english_prompt.startswith('"') and english_prompt.endswith('"'):
            english_prompt = english_prompt[1:-1]

        log(f"âœ… è‹±æ–‡prompt: {english_prompt[:100]}...")

        # ä½¿ç”¨WavespeedAIç”Ÿæˆå‚è€ƒå›¾
        log("")
        log("ğŸ¨ ç”Ÿæˆä¸»è§’å‚è€ƒå›¾...")

        image_url = generate_image(english_prompt, shot_id=0, shot_count=1)

        # ä¿å­˜promptåˆ°æ–‡ä»¶
        ref_file = WORK_DIR / '12_character_reference_prompt.txt'
        with open(ref_file, 'w', encoding='utf-8') as f:
            f.write(f"ä¸­æ–‡æè¿°ï¼š{character_description_cn}\n\n")
            f.write(f"è‹±æ–‡Promptï¼š{english_prompt}\n\n")
            f.write(f"å‚è€ƒå›¾URLï¼š{image_url}\n")

        log(f"âœ… ä¸»è§’å‚è€ƒå›¾å·²ç”Ÿæˆ")
        log(f"   å‚è€ƒå›¾URL: {image_url}")
        log("")

        return {
            'description_cn': character_description_cn,
            'prompt_en': english_prompt,
            'image_url': image_url
        }

    except Exception as e:
        log(f"âŒ ç”Ÿæˆä¸»è§’å‚è€ƒå›¾å¤±è´¥: {e}", "ERROR")
        raise

def extract_character_dna(character_ref):
    """ä½¿ç”¨DeepSeekæå–è§’è‰²DNAï¼ˆè¯¦ç»†å¤–è§‚æè¿°ï¼‰

    Args:
        character_ref: dict, åŒ…å«description_cn, prompt_en, image_url

    Returns:
        str: è§’è‰²DNAï¼ˆè¯¦ç»†è‹±æ–‡æè¿°ï¼Œç”¨äºæ‰€æœ‰é•œå¤´ï¼‰
    """
    log("ğŸ§¬ æå–è§’è‰²DNAï¼ˆè¯¦ç»†ç‰¹å¾æè¿°ï¼‰...")

    # å¦‚æœæè¿°å¾ˆç®€å•ï¼ˆå¦‚é»˜è®¤å€¼ï¼‰ï¼Œè¯´æ˜ç”¨æˆ·ä¸»è¦ä¾èµ–å›¾ç‰‡
    description = character_ref.get('description_cn', '')
    if len(description) <= 10:
        simple_dna = "The character as shown in the reference image."
        log(f"   ä½¿ç”¨å‚è€ƒå›¾ç‰‡æ¨¡å¼ï¼ˆç®€åŒ–DNAï¼‰")
        dna_file = WORK_DIR / '10_character_dna.txt'
        with open(dna_file, 'w', encoding='utf-8') as f:
            f.write(simple_dna)
        log(f"âœ… è§’è‰²DNAå·²ç”Ÿæˆï¼ˆåŸºäºå‚è€ƒå›¾ï¼‰\n")
        return simple_dna

    dna_prompt = f"""åŸºäºä»¥ä¸‹è§’è‰²æè¿°ï¼Œç”Ÿæˆä¸€ä¸ª**æå…¶è¯¦ç»†**çš„è‹±æ–‡å¤–è§‚æè¿°ï¼ˆCharacter DNAï¼‰ï¼Œ
ç”¨äºAIè§†é¢‘ç”Ÿæˆæ—¶ä¿æŒè§’è‰²ä¸€è‡´æ€§ã€‚

åŸå§‹æè¿°ï¼š{description}
å‚è€ƒpromptï¼š{character_ref['prompt_en']}

è¯·ç”Ÿæˆä¸€ä¸ª100-150è¯çš„è¯¦ç»†è‹±æ–‡æè¿°ï¼ŒåŒ…å«ï¼š
1. æ•´ä½“å¤–è§‚å’Œèº«é«˜æ¯”ä¾‹
2. é¢éƒ¨ç‰¹å¾ï¼ˆçœ¼ç›é¢œè‰²ã€å½¢çŠ¶ã€å¤§å°ã€å‘å…‰æ•ˆæœï¼‰
3. èº«ä½“/å¤–å£³ç‰¹å¾ï¼ˆæè´¨ã€é¢œè‰²ã€è®¾è®¡ç»†èŠ‚ï¼‰
4. æœè£…/è£…ç”²ï¼ˆæ¬¾å¼ã€é¢œè‰²ã€é…é¥°ï¼‰
5. ç‹¬ç‰¹æ ‡è¯†ï¼ˆlogoã€çº¹ç†ã€å‘å…‰éƒ¨ä½ï¼‰
6. å§¿æ€å’Œæ°”è´¨

æ ¼å¼è¦æ±‚ï¼š
- ç”¨è‹±æ–‡
- ç¬¬ä¸‰äººç§°æè¿°ï¼ˆå¦‚"She has..."æˆ–"The robot features..."ï¼‰
- é€‚åˆä½œä¸ºAIè§†é¢‘ç”Ÿæˆpromptçš„å‰ç¼€
- å…·ä½“ã€è¯¦ç»†ã€ä¸“ä¸š

ç¤ºä¾‹ï¼š
"An elegant female humanoid AI assistant robot, standing approximately 175cm tall with graceful posture. Her face features large, luminous electric-blue eyes with subtle LED patterns, smooth white ceramic-like facial structure with gentle contours. The body is constructed from pristine white metallic panels with seamless joints, accented by glowing orange LED strips running along the arms, torso, and legs. Hair-like fiber optic strands flow from her head in translucent blue hues. A small Akamai logo is embossed on the chest plate. Her movements are fluid and elegant, embodying a perfect blend of advanced technology and human-like grace."

åªè¿”å›è‹±æ–‡æè¿°ï¼Œä¸è¦å…¶ä»–å†…å®¹ã€‚
"""

    url = "https://api.deepseek.com/v1/chat/completions"
    headers = {
        "Authorization": f"Bearer {DEEPSEEK_API_KEY}",
        "Content-Type": "application/json"
    }

    payload = {
        "model": "deepseek-chat",
        "messages": [{"role": "user", "content": dna_prompt}],
        "temperature": 0.5
    }

    try:
        # APIé™æµæ§åˆ¶
        deepseek_limiter.acquire()
        response = requests.post(url, headers=headers, json=payload, timeout=60)
        response.raise_for_status()
        result = response.json()
        character_dna = result['choices'][0]['message']['content'].strip()

        # ç§»é™¤å¯èƒ½çš„å¼•å·
        if character_dna.startswith('"') and character_dna.endswith('"'):
            character_dna = character_dna[1:-1]

        # ä¿å­˜DNAåˆ°æ–‡ä»¶
        dna_file = WORK_DIR / '10_character_dna.txt'
        with open(dna_file, 'w', encoding='utf-8') as f:
            f.write(character_dna)

        log(f"âœ… è§’è‰²DNAå·²ç”Ÿæˆ")
        log(f"   {character_dna[:80]}...")
        log("")

        return character_dna

    except Exception as e:
        log(f"âŒ æå–è§’è‰²DNAå¤±è´¥: {e}", "ERROR")
        raise

def prepare_brand_assets(brand_config):
    """å‡†å¤‡å“ç‰Œèµ„äº§ï¼ˆlogoç­‰ï¼‰

    Args:
        brand_config: dict, å“ç‰Œé…ç½®ä¿¡æ¯ï¼ˆåŒ…å«default_logo_imageï¼‰

    Returns:
        dict: å“ç‰Œèµ„äº§ä¿¡æ¯
    """
    log("")
    log("="*60)
    log("ğŸ¢ å‡†å¤‡å“ç‰Œèµ„äº§")
    log("="*60)

    assets = {
        'enabled': brand_config.get('enabled', False),
        'name': brand_config.get('name', ''),
        'logo_path': None,
        'position': brand_config.get('position', 'top-right'),
        'scale': 100,  # logoå®½åº¦ï¼ˆåƒç´ ï¼‰
        'opacity': 0.9
    }

    if not assets['enabled']:
        log("   å“ç‰Œå åŠ æœªå¯ç”¨")
        return assets

    # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æä¾›äº†logoå›¾ç‰‡
    logo_path = brand_config.get('logo_image')
    if logo_path:
        log(f"   ä½¿ç”¨ç”¨æˆ·æŒ‡å®šçš„Logo: {logo_path}")
    else:
        # ä½¿ç”¨é»˜è®¤logoï¼ˆä»é…ç½®æ–‡ä»¶è¯»å–ï¼‰
        logo_path = brand_config.get('default_logo_image', './resource/logo/aka.jpg')
        log(f"   ä½¿ç”¨é»˜è®¤Logo: {logo_path}")

    # æ£€æŸ¥æ˜¯ URL è¿˜æ˜¯æœ¬åœ°æ–‡ä»¶
    if logo_path.startswith(('http://', 'https://')):
        # URL å›¾ç‰‡ï¼Œç›´æ¥ä½¿ç”¨
        log(f"   âœ“ ä½¿ç”¨åœ¨çº¿Logoï¼ˆURLï¼‰")
        assets['logo_path'] = logo_path
    else:
        # æœ¬åœ°æ–‡ä»¶ï¼Œæ£€æŸ¥æ˜¯å¦å­˜åœ¨å¹¶å¤åˆ¶åˆ°å·¥ä½œç›®å½•
        logo_file = Path(logo_path)
        if not logo_file.exists():
            log(f"âš ï¸  Logoæ–‡ä»¶ä¸å­˜åœ¨: {logo_path}ï¼Œè·³è¿‡å“ç‰Œå åŠ ", "WARN")
            assets['enabled'] = False
            return assets

        # å¤åˆ¶logoåˆ°å·¥ä½œç›®å½•ï¼ˆä¿ç•™åŸå§‹æ‰©å±•åï¼‰
        logo_ext = logo_file.suffix
        work_logo = WORK_DIR / f'11_brand_logo{logo_ext}'
        import shutil
        shutil.copy(logo_file, work_logo)

        assets['logo_path'] = str(work_logo)
        log(f"   âœ“ Logoå·²æ‹·è´åˆ°é¡¹ç›®ç›®å½•")

    log(f"âœ… å“ç‰Œèµ„äº§å·²å‡†å¤‡")
    log(f"   Logo: {assets['logo_path']}")
    log(f"   ä½ç½®: {assets['position']}")
    log(f"   å¤§å°: {assets['scale']}px")
    log("")

    return assets

def add_brand_overlay(video_path, brand_assets):
    """ä½¿ç”¨FFmpegä¸ºè§†é¢‘æ·»åŠ å“ç‰Œlogoæ°´å°

    Args:
        video_path: str, è¾“å…¥è§†é¢‘è·¯å¾„
        brand_assets: dict, å“ç‰Œèµ„äº§é…ç½®

    Returns:
        str: æ·»åŠ å“ç‰Œåçš„è§†é¢‘è·¯å¾„
    """
    if not brand_assets.get('enabled') or not brand_assets.get('logo_path'):
        return video_path

    import subprocess

    output_path = video_path.replace('.mp4', '_branded.mp4')

    # è®¡ç®—logoä½ç½®
    position_map = {
        'bottom-right': 'W-w-20:H-h-20',
        'bottom-left': '20:H-h-20',
        'top-right': 'W-w-20:20',
        'top-left': '20:20'
    }

    position = position_map.get(brand_assets['position'], 'W-w-20:20')

    # FFmpegå‘½ä»¤ï¼šå åŠ logo
    cmd = [
        'ffmpeg',
        '-i', video_path,
        '-i', brand_assets['logo_path'],
        '-filter_complex',
        f"[1:v]scale={brand_assets['scale']}:-1[logo];"
        f"[0:v][logo]overlay={position}:format=auto",
        '-c:v', 'libx264',
        '-preset', 'medium',
        '-crf', '23',
        '-c:a', 'copy',
        '-y',  # è¦†ç›–è¾“å‡ºæ–‡ä»¶
        output_path
    ]

    try:
        log(f"   ğŸ¨ æ·»åŠ å“ç‰Œlogoåˆ°è§†é¢‘...")
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=120
        )

        if result.returncode != 0:
            log(f"âš ï¸  FFmpegè­¦å‘Š: {result.stderr[:200]}", "WARN")
            # å¦‚æœå¤±è´¥ï¼Œè¿”å›åŸè§†é¢‘
            return video_path

        # åˆ é™¤åŸè§†é¢‘ï¼Œé‡å‘½åä¸ºåŸæ–‡ä»¶åï¼ˆèŠ‚çœç©ºé—´ï¼‰
        import os
        os.remove(video_path)
        os.rename(output_path, video_path)

        log(f"   âœ… å“ç‰Œlogoå·²æ·»åŠ ")
        return video_path

    except subprocess.TimeoutExpired:
        log(f"âš ï¸  æ·»åŠ å“ç‰Œè¶…æ—¶ï¼Œä½¿ç”¨åŸè§†é¢‘", "WARN")
        return video_path
    except Exception as e:
        log(f"âš ï¸  æ·»åŠ å“ç‰Œå¤±è´¥: {e}ï¼Œä½¿ç”¨åŸè§†é¢‘", "WARN")
        return video_path

# ============================================================
# æ•…äº‹ç”Ÿæˆç³»ç»Ÿ
# ============================================================

def generate_story_outline(config):
    """ç”Ÿæˆæ•…äº‹å¤§çº²ï¼ˆç¬¬ä¸€é˜¶æ®µï¼‰

    Args:
        config: dict, åŒ…å«topic, style, shot_countç­‰é…ç½®

    Returns:
        dict: æ•…äº‹å¤§çº²æ•°æ®
    """
    log("-" * 30)
    log("ğŸ“– é˜¶æ®µ1: ç”Ÿæˆæ•…äº‹å¤§çº²")
    log("-" * 60)

    style_template = STYLE_TEMPLATES[config['style']]

    prompt = f"""ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„è§†é¢‘è„šæœ¬ç­–åˆ’å¸ˆã€‚è¯·ä¸ºä»¥ä¸‹ä¸»é¢˜åˆ›ä½œä¸€ä¸ª{config['shot_count']}é•œå¤´çš„çŸ­è§†é¢‘æ•…äº‹å¤§çº²ã€‚

ä¸»é¢˜ï¼š{config['topic']}
è§†è§‰é£æ ¼ï¼š{style_template['name']}
é•œå¤´æ•°ï¼š{config['shot_count']}ä¸ª

æ•…äº‹ç»“æ„è¦æ±‚ï¼ˆèµ·æ‰¿è½¬åˆï¼‰ï¼š
1. æ¯ä¸ªé•œå¤´æ˜¯æ•…äº‹çš„æœ‰æœºç»„æˆéƒ¨åˆ†ï¼Œä¸æ˜¯ç‹¬ç«‹çš„ç‰‡æ®µ
2. é•œå¤´ä¹‹é—´æœ‰æ˜ç¡®çš„å› æœå…³ç³»æˆ–æ—¶é—´æ¨è¿›
3. è§†è§‰é£æ ¼ç»Ÿä¸€ï¼š{style_template['visual_style']}
4. è‰²å½©åŸºè°ƒï¼š{style_template['color_palette']}

è¯·ä»¥JSONæ ¼å¼è¾“å‡ºæ•…äº‹å¤§çº²ï¼š
{{
  "title": "æ•…äº‹æ ‡é¢˜",
  "theme": "æ ¸å¿ƒä¸»é¢˜ï¼ˆä¸€å¥è¯ï¼‰",
  "visual_theme": {{
    "primary_colors": ["{style_template['color_palette'].split(',')[0].strip()}", "{style_template['color_palette'].split(',')[1].strip()}"],
    "mood": "{style_template['mood']}"
  }},
  "shot_breakdown": [
    {{
      "shot_number": 1,
      "scene_summary": "é•œå¤´å†…å®¹æ¦‚è¦ï¼ˆ20å­—å†…ï¼‰",
      "key_action": "å…³é”®åŠ¨ä½œæˆ–è§†è§‰é‡ç‚¹",
      "transition_to_next": "ä¸ä¸‹ä¸€é•œå¤´çš„è¿æ¥ç‚¹"
    }}
    // ... {config['shot_count']}ä¸ªé•œå¤´
  ]
}}
"""

    url = "https://api.deepseek.com/v1/chat/completions"
    headers = {
        "Authorization": f"Bearer {DEEPSEEK_API_KEY}",
        "Content-Type": "application/json"
    }

    payload = {
        "model": "deepseek-chat",
        "messages": [{"role": "user", "content": prompt}],
        "temperature": 0.8
    }

    try:
        log("   ğŸ“¤ å‡†å¤‡è°ƒç”¨DeepSeek API...")
        log("")
        log("=" * 60)
        log("ğŸ“ å‘é€çš„æç¤ºè¯:")
        log("=" * 60)
        log(prompt)
        log("=" * 60)
        log("")

        log("   ğŸ”„ æ­£åœ¨è°ƒç”¨DeepSeek APIï¼Œè¯·ç¨å€™...")
        # APIé™æµæ§åˆ¶
        deepseek_limiter.acquire()
        response = requests.post(url, headers=headers, json=payload, timeout=60)
        response.raise_for_status()
        result = response.json()
        content = result['choices'][0]['message']['content']

        log("")
        log("=" * 60)
        log("ğŸ“¥ DeepSeek API è¿”å›ç»“æœ:")
        log("=" * 60)
        log(content)
        log("=" * 60)
        log("")

        # æå–JSON
        log("   ğŸ” æ­£åœ¨è§£æJSON...")
        json_content = content
        if '```json' in content:
            json_content = content.split('```json')[1].split('```')[0].strip()
        elif '```' in content:
            json_content = content.split('```')[1].split('```')[0].strip()

        outline = json.loads(json_content)

        log("   âœ… JSONè§£ææˆåŠŸ")
        log("")
        log("=" * 60)
        log("ğŸ“Š è§£æåçš„æ•…äº‹å¤§çº²:")
        log("=" * 60)
        log(json.dumps(outline, indent=2, ensure_ascii=False))
        log("=" * 60)
        log("")

        # ä¿å­˜æ•…äº‹å¤§çº²
        outline_file = WORK_DIR / '20_story_outline.json'
        with open(outline_file, 'w', encoding='utf-8') as f:
            json.dump(outline, f, indent=2, ensure_ascii=False)

        log(f"âœ… æ•…äº‹å¤§çº²å·²ç”Ÿæˆï¼š{outline_file}")
        log(f"   æ ‡é¢˜: {outline.get('title', 'N/A')}")
        log(f"   ä¸»é¢˜: {outline.get('theme', 'N/A')}")
        log(f"   é•œå¤´æ•°: {len(outline.get('shot_breakdown', []))}")
        log("")

        # è¯¦ç»†æ˜¾ç¤ºæ¯ä¸ªé•œå¤´çš„å¤§çº²
        log("ğŸ“‹ æ•…äº‹å¤§çº²è¯¦æƒ…:")
        for i, shot in enumerate(outline.get('shot_breakdown', []), 1):
            log(f"   é•œå¤´ {i}:")
            log(f"      åœºæ™¯: {shot.get('scene_summary', 'N/A')}")
            log(f"      åŠ¨ä½œ: {shot.get('key_action', 'N/A')}")
            if shot.get('transition_to_next'):
                log(f"      è½¬åœº: {shot.get('transition_to_next', 'N/A')}")
            log("")

        log("-" * 60)

        return outline

    except Exception as e:
        log(f"âŒ ç”Ÿæˆæ•…äº‹å¤§çº²å¤±è´¥ï¼š{e}", "ERROR")
        raise

def generate_narration_framework(outline, config):
    """ç”Ÿæˆå¹¿å‘Šè¯æ•´ä½“æ¡†æ¶ï¼ˆæ–°å¢é˜¶æ®µ1.5ï¼‰

    Args:
        outline: dict, æ•…äº‹å¤§çº²
        config: dict, é…ç½®ä¿¡æ¯

    Returns:
        dict: å¹¿å‘Šè¯æ¡†æ¶ {
            "overall_tagline": "æ•´ä½“ä¸»çº¿",
            "narration_style": "è¯­è¨€é£æ ¼",
            "shot_points": [æ¯ä¸ªé•œå¤´çš„æ ¸å¿ƒè¦ç‚¹]
        }
    """
    log("")
    log("-" * 30)
    log("ğŸ™ï¸  é˜¶æ®µ1.5: ç”Ÿæˆå¹¿å‘Šè¯æ¡†æ¶")
    log("-" * 60)

    # è®¡ç®—æ¯ä¸ªé•œå¤´çš„æ—¶é•¿ï¼ˆä»configä¸­è·å–ï¼Œé»˜è®¤5ç§’ï¼‰
    shot_duration = config.get('duration', 5)
    total_duration = shot_duration * config['shot_count']

    # ä»é…ç½®æ–‡ä»¶è¯»å–æ—ç™½è¯­é€Ÿï¼ˆé»˜è®¤3.0å­—/ç§’ï¼Œæ›´ä¿å®ˆè‡ªç„¶ï¼‰
    audio_config = CONFIG.get('audio', {})
    CHARS_PER_SECOND = audio_config.get('chars_per_second', 3.0)
    log(f"   æ—ç™½è¯­é€Ÿ: {CHARS_PER_SECOND}å­—/ç§’")

    prompt = f"""ä½ æ˜¯ä¸€ä½èµ„æ·±å¹¿å‘Šæ–‡æ¡ˆå¤§å¸ˆã€‚è¯·ä¸ºä»¥ä¸‹æ•…äº‹åˆ›ä½œå¹¿å‘Šè¯æ•´ä½“æ¡†æ¶ã€‚

ä¸»é¢˜ï¼š{config['topic']}
æ•…äº‹æ ‡é¢˜ï¼š{outline.get('title', 'N/A')}
æ ¸å¿ƒä¸»é¢˜ï¼š{outline.get('theme', 'N/A')}
è§†é¢‘æ€»æ—¶é•¿ï¼š{total_duration}ç§’ï¼ˆ{config['shot_count']}ä¸ªé•œå¤´ï¼Œæ¯é•œå¤´{shot_duration}ç§’ï¼‰
é…éŸ³è¯­é€Ÿï¼š{CHARS_PER_SECOND}å­—/ç§’

æ•…äº‹åˆ†é•œæ¦‚è¦ï¼š
{chr(10).join([f"{i+1}. {beat['scene_summary']} - {beat['key_action']}" for i, beat in enumerate(outline['shot_breakdown'])])}

åˆ›ä½œè¦æ±‚ï¼š
1. **æ•´ä½“å®šä½**ï¼šç¡®å®šå¹¿å‘Šè¯çš„ä¸»çº¿ï¼ˆä¸€å¥è¯ï¼Œå¦‚"æ¢ç´¢æœªçŸ¥ï¼Œç‚¹ç‡ƒæ¿€æƒ…"ï¼‰
2. **è¯­è¨€é£æ ¼**ï¼šå®šä¹‰æ–‡æ¡ˆçš„è¯­è¨€ç‰¹è‰²ï¼Œè¦æ±‚ï¼š
   - âŒ ç¦æ­¢å››å­—æˆè¯­å †ç Œ
   - âœ… å¿…é¡»é•¿çŸ­å¥ç»“åˆï¼ˆçŸ­å¥å†²å‡»+é•¿å¥é“ºé™ˆï¼‰
   - è‡ªç„¶æµç•…ï¼ŒåƒçœŸå®çš„å¹¿å‘Šé…éŸ³
   - é£æ ¼ç¤ºä¾‹ï¼š"è¯—æ„å™äº‹å‹"ã€"æ‚¬å¿µé€’è¿›å‹"ã€"æƒ…æ„Ÿå…±é¸£å‹"
3. **åˆ†æ®µè¦ç‚¹**ï¼šä¸ºæ¯ä¸ªé•œå¤´åˆ†é…æ ¸å¿ƒè¡¨è¾¾è¦ç‚¹ï¼Œç¡®ä¿ï¼š
   - å…¨ç‰‡å™äº‹è¿è´¯é€’è¿›ï¼ˆå¼•å…¥â†’å±•å¼€â†’é«˜æ½®â†’å‡åï¼‰
   - æ¯æ®µè¦ç‚¹ä¸é‡å¤ã€ä¸è·³è·ƒ
   - ä¸ç”»é¢å†…å®¹ç´§å¯†å‘¼åº”

æ³¨æ„äº‹é¡¹ï¼š
- ä¸è¦ç”Ÿæˆå…·ä½“æ–‡æ¡ˆï¼Œåªéœ€æ¡†æ¶æ€§æŒ‡å¯¼
- ç¡®ä¿æƒ…æ„Ÿé€’è¿›è‡ªç„¶ï¼ˆå¹³å’Œâ†’æ¿€æ˜‚â†’éœ‡æ’¼ï¼‰
- é¿å…ç©ºæ´è¯æ±‡ï¼ˆåˆ›æ–°ã€å¼ºå¤§ã€å®Œç¾ç­‰ï¼‰
- å¼ºè°ƒé•¿çŸ­å¥äº¤æ›¿çš„èŠ‚å¥æ„Ÿ

è¯·ä»¥JSONæ ¼å¼è¾“å‡ºï¼š
{{
  "overall_tagline": "æ•´ä½“ä¸»çº¿ï¼ˆä¸€å¥è¯ï¼‰",
  "narration_style": "è¯­è¨€é£æ ¼æè¿°",
  "emotion_arc": "æƒ…æ„Ÿæ›²çº¿ï¼ˆå¦‚ï¼šå¹³é™â†’å¥½å¥‡â†’æŒ¯å¥‹â†’éœ‡æ’¼ï¼‰",
  "shot_points": [
    {{
      "shot_number": 1,
      "core_message": "æœ¬é•œå¤´æ ¸å¿ƒè¦ä¼ è¾¾çš„ä¿¡æ¯",
      "emotion": "æœ¬é•œå¤´çš„æƒ…æ„ŸåŸºè°ƒ",
      "connection": "ä¸ä¸Šä¸‹é•œå¤´çš„å…³ç³»"
    }}
    // ... {config['shot_count']}ä¸ªé•œå¤´
  ]
}}
"""

    url = "https://api.deepseek.com/v1/chat/completions"
    headers = {
        "Authorization": f"Bearer {DEEPSEEK_API_KEY}",
        "Content-Type": "application/json"
    }

    payload = {
        "model": "deepseek-chat",
        "messages": [{"role": "user", "content": prompt}],
        "temperature": 0.8
    }

    try:
        log("   ğŸ”„ æ­£åœ¨è°ƒç”¨DeepSeek APIç”Ÿæˆå¹¿å‘Šè¯æ¡†æ¶...")
        deepseek_limiter.acquire()
        response = requests.post(url, headers=headers, json=payload, timeout=60)
        response.raise_for_status()
        result = response.json()
        content = result['choices'][0]['message']['content']

        # æå–JSON
        json_content = content
        if '```json' in content:
            json_content = content.split('```json')[1].split('```')[0].strip()
        elif '```' in content:
            json_content = content.split('```')[1].split('```')[0].strip()

        framework = json.loads(json_content)

        # ä¿å­˜æ¡†æ¶
        framework_file = WORK_DIR / '21_narration_framework.json'
        with open(framework_file, 'w', encoding='utf-8') as f:
            json.dump(framework, f, indent=2, ensure_ascii=False)

        log(f"âœ… å¹¿å‘Šè¯æ¡†æ¶å·²ç”Ÿæˆï¼š{framework_file}")
        log(f"   ä¸»çº¿: {framework.get('overall_tagline', 'N/A')}")
        log(f"   é£æ ¼: {framework.get('narration_style', 'N/A')}")
        log(f"   æƒ…æ„Ÿæ›²çº¿: {framework.get('emotion_arc', 'N/A')}")
        log("")

        # æ˜¾ç¤ºæ¯ä¸ªé•œå¤´çš„è¦ç‚¹
        log("ğŸ“‹ åˆ†é•œè¦ç‚¹:")
        for point in framework.get('shot_points', []):
            log(f"   é•œå¤´ {point['shot_number']}: {point['core_message']}")
        log("")
        log("-" * 60)

        return framework

    except Exception as e:
        log(f"âŒ ç”Ÿæˆå¹¿å‘Šè¯æ¡†æ¶å¤±è´¥ï¼š{e}", "ERROR")
        raise

def generate_coherent_shots(outline, config, narration_framework=None):
    """åŸºäºæ•…äº‹å¤§çº²ç”Ÿæˆè¿è´¯çš„åˆ†é•œè„šæœ¬ï¼ˆç¬¬äºŒé˜¶æ®µï¼‰

    Args:
        outline: dict, æ•…äº‹å¤§çº²
        config: dict, é…ç½®ä¿¡æ¯
        narration_framework: dict, å¹¿å‘Šè¯æ¡†æ¶ï¼ˆå¯é€‰ï¼‰

    Returns:
        dict: åŒ…å«è¿è´¯é•œå¤´æè¿°çš„å­—å…¸
    """
    log("")
    log("-" * 30)
    log("ğŸ¬ é˜¶æ®µ2: ç”Ÿæˆè¿è´¯åˆ†é•œè„šæœ¬")
    log("-" * 60)

    # ä»é…ç½®æ–‡ä»¶è¯»å–æ—ç™½è¯­é€Ÿï¼ˆé»˜è®¤3.0å­—/ç§’ï¼Œæ›´ä¿å®ˆè‡ªç„¶ï¼‰
    audio_config = CONFIG.get('audio', {})
    CHARS_PER_SECOND = audio_config.get('chars_per_second', 3.0)
    shot_duration = config.get('duration', 5)
    log(f"   æ—ç™½è¯­é€Ÿ: {CHARS_PER_SECOND}å­—/ç§’ (ç›®æ ‡: {CHARS_PER_SECOND * shot_duration:.0f}å­—/{shot_duration}ç§’)")

    style_template = STYLE_TEMPLATES[config['style']]
    shots = []
    previous_narrations = []  # è®°å½•å·²ç”Ÿæˆçš„æ—ç™½ï¼Œé¿å…é‡å¤

    for i, beat in enumerate(outline['shot_breakdown']):
        prev_beat = outline['shot_breakdown'][i-1] if i > 0 else None
        next_beat = outline['shot_breakdown'][i+1] if i < len(outline['shot_breakdown'])-1 else None

        log("")
        log(f"   ğŸ“ ç”Ÿæˆé•œå¤´ {i+1}/{config['shot_count']}: {beat['scene_summary']}")

        # å‡†å¤‡ä¸»è§’ä¿¡æ¯ï¼ˆå¦‚æœå¯ç”¨ï¼‰
        character_section = ""
        if config.get('character', {}).get('enabled') and config['character'].get('dna'):
            character_dna = config['character']['dna']
            character_section = f"""
ä¸»è§’ä¿¡æ¯ï¼ˆå¿…é¡»ä¸¥æ ¼éµå®ˆï¼‰ï¼š
{character_dna}

é‡è¦ï¼šä¸»è§’åœ¨æ¯ä¸ªé•œå¤´ä¸­çš„å¤–è§‚å¿…é¡»ä¸ä¸Šè¿°æè¿°100%ä¸€è‡´ï¼
"""

        prompt = f"""åŸºäºæ•…äº‹å¤§çº²ï¼Œç”Ÿæˆç¬¬{i+1}ä¸ªé•œå¤´çš„è¯¦ç»†è‹±æ–‡promptï¼ˆç”¨äºAIè§†é¢‘ç”Ÿæˆï¼‰ã€‚

æ•´ä½“æ•…äº‹ï¼š{outline['theme']}
è§†è§‰ä¸»é¢˜ï¼šè‰²è°ƒ{outline['visual_theme']['primary_colors']}ï¼Œæ°›å›´{outline['visual_theme']['mood']}
{character_section}
å½“å‰é•œå¤´ï¼ˆ{i+1}/{config['shot_count']}ï¼‰ï¼š
- åœºæ™¯æ¦‚è¦ï¼š{beat['scene_summary']}
- å…³é”®åŠ¨ä½œï¼š{beat['key_action']}

{"å‰ä¸€é•œå¤´ï¼š" + prev_beat['key_action'] if prev_beat else "è¿™æ˜¯å¼€åœºé•œå¤´"}
{"ä¸‹ä¸€é•œå¤´é“ºå«ï¼š" + beat['transition_to_next'] if next_beat else "è¿™æ˜¯ç»“æŸé•œå¤´"}

é£æ ¼è¦æ±‚ï¼š
- è§†è§‰é£æ ¼ï¼š{style_template['visual_style']}
- è‰²å½©æ–¹æ¡ˆï¼š{style_template['color_palette']}
- å…‰å½±ï¼š{style_template['lighting']}
- é•œå¤´è¿åŠ¨ï¼š{style_template['camera_movement']}

è¯·ç”Ÿæˆä¸€ä¸ª80-120è¯çš„è¯¦ç»†è‹±æ–‡promptï¼Œè¦æ±‚ï¼š
1. {"å¦‚æœæœ‰ä¸»è§’ï¼Œå¿…é¡»ä»¥ä¸»è§’æè¿°ä½œä¸ºå¼€å¤´ï¼ˆå®Œæ•´å¤åˆ¶ä¸»è§’ä¿¡æ¯ï¼‰" if character_section else "åŒ…å«å…·ä½“çš„è§†è§‰æè¿°ï¼ˆåœºæ™¯ã€ä¸»ä½“ã€åŠ¨ä½œï¼‰"}
2. {"ä½“ç°ä¸å‰ä¸€é•œå¤´çš„è¿ç»­æ€§" if prev_beat else "å¼€åœºè¦å¸å¼•äºº"}
3. {"ä¸ºä¸‹ä¸€é•œå¤´åšé“ºå«" if next_beat else "ç»“å°¾è¦æœ‰å‡å"}
4. ä¸¥æ ¼éµå®ˆä¸Šè¿°é£æ ¼æ¨¡æ¿
5. ä½¿ç”¨cinematicä¸“ä¸šæœ¯è¯­

åªè¿”å›promptæ–‡æœ¬ï¼Œä¸è¦å…¶ä»–å†…å®¹ã€‚
"""

        url = "https://api.deepseek.com/v1/chat/completions"
        headers = {
            "Authorization": f"Bearer {DEEPSEEK_API_KEY}",
            "Content-Type": "application/json"
        }

        payload = {
            "model": "deepseek-chat",
            "messages": [{"role": "user", "content": prompt}],
            "temperature": 0.7
        }

        try:
            # APIé™æµæ§åˆ¶
            deepseek_limiter.acquire()
            response = requests.post(url, headers=headers, json=payload, timeout=60)
            response.raise_for_status()
            result = response.json()
            shot_prompt = result['choices'][0]['message']['content'].strip()

            # ç§»é™¤å¯èƒ½çš„markdownæ ¼å¼
            if shot_prompt.startswith('"') and shot_prompt.endswith('"'):
                shot_prompt = shot_prompt[1:-1]

            # ============================================================
            # ã€æ–¹æ¡ˆ2ã€‘ç”Ÿæˆæ—ç™½ï¼šåŸºäºæ¡†æ¶ + ç²¾ç¡®å­—æ•° + æ—¶é•¿éªŒè¯
            # ============================================================

            # è®¡ç®—ç›®æ ‡å­—æ•°ï¼ˆç²¾ç¡®åŒ¹é…é•œå¤´æ—¶é•¿ï¼Œåç»­é€šè¿‡åŠ é€Ÿæ§åˆ¶ï¼‰
            target_chars = int(shot_duration * CHARS_PER_SECOND)
            min_chars = int(target_chars * 0.85)
            max_chars = int(target_chars * 1.15)

            log(f"   ğŸ“Š é•œå¤´æ—¶é•¿: {shot_duration}ç§’ â†’ ç›®æ ‡å­—æ•°: {target_chars} ({min_chars}-{max_chars})")

            # è·å–æ¡†æ¶æŒ‡å¯¼ä¿¡æ¯
            framework_guidance = ""
            if narration_framework and narration_framework.get('shot_points'):
                shot_point = narration_framework['shot_points'][i]
                framework_guidance = f"""
ã€å¹¿å‘Šè¯æ¡†æ¶æŒ‡å¯¼ã€‘
æ•´ä½“ä¸»çº¿ï¼š{narration_framework.get('overall_tagline', '')}
è¯­è¨€é£æ ¼ï¼š{narration_framework.get('narration_style', '')}
æœ¬é•œå¤´è¦ç‚¹ï¼š{shot_point.get('core_message', '')}
æƒ…æ„ŸåŸºè°ƒï¼š{shot_point.get('emotion', '')}
ä¸å‰åå…³ç³»ï¼š{shot_point.get('connection', '')}
"""

            # æ„å»ºå‰æ–‡æ¦‚è¦
            previous_context = ""
            if previous_narrations:
                previous_context = f"\nã€å‰åºæ—ç™½ã€‘ï¼ˆä¿æŒè¿è´¯ï¼Œé¿å…é‡å¤ï¼‰\n" + "\n".join([f"é•œå¤´{idx+1}: \"{text}\"" for idx, text in enumerate(previous_narrations)])

            # ç”Ÿæˆæ—ç™½ï¼ˆæ”¯æŒé‡è¯•æœºåˆ¶ï¼‰
            narration_text = None
            actual_duration = 0
            max_retries = 2

            for attempt in range(max_retries + 1):
                # æ ¹æ®ä¸Šæ¬¡ç»“æœå¾®è°ƒå­—æ•°
                if attempt > 0:
                    if actual_duration > shot_duration * 1.1:
                        # è¶…æ—¶ï¼Œå‡å°‘å­—æ•°
                        adjustment = int(target_chars * 0.15)
                        target_chars = max(min_chars, target_chars - adjustment)
                        log(f"   ğŸ”„ é‡è¯• {attempt}/{max_retries}: ä¸Šæ¬¡è¶…æ—¶{actual_duration:.1f}sï¼Œå‡å°‘è‡³{target_chars}å­—")
                    elif actual_duration < shot_duration * 0.8:
                        # å¤ªçŸ­ï¼Œå¢åŠ å­—æ•°
                        adjustment = int(target_chars * 0.15)
                        target_chars = min(max_chars, target_chars + adjustment)
                        log(f"   ğŸ”„ é‡è¯• {attempt}/{max_retries}: ä¸Šæ¬¡è¿‡çŸ­{actual_duration:.1f}sï¼Œå¢åŠ è‡³{target_chars}å­—")

                narration_prompt = f"""ä¸ºè¿™ä¸ªå¹¿å‘Šè§†é¢‘é•œå¤´åˆ›ä½œé…éŸ³æ–‡æ¡ˆï¼ˆä¸­æ–‡ï¼‰ã€‚

ã€é•œå¤´ä¿¡æ¯ã€‘
åœºæ™¯ï¼š{beat['scene_summary']}
åŠ¨ä½œï¼š{beat['key_action']}
ä½ç½®ï¼šç¬¬{i+1}/{config['shot_count']}ä¸ªé•œå¤´
æ—¶é•¿ï¼š{shot_duration}ç§’
{framework_guidance}{previous_context}

ã€æ ¸å¿ƒè¦æ±‚ã€‘
1. **å­—æ•°ç²¾ç¡®**ï¼šä¸¥æ ¼{target_chars}å­—å·¦å³ï¼ˆÂ±2å­—ï¼‰ï¼Œå¯¹åº”{shot_duration}ç§’é…éŸ³
2. **é•¿çŸ­å¥ç»“åˆ**ï¼ˆæœ€é‡è¦ï¼ï¼‰ï¼š
   - âŒ ä¸¥ç¦ï¼šçº¯å››å­—æˆè¯­ï¼ˆå¦‚"ç ´ç¢å‡è§†ï¼Œæ•°æ®æ¶ŒåŠ¨"ï¼‰
   - âœ… å¿…é¡»ï¼šçŸ­å¥(3-6å­—) + é•¿å¥(8-15å­—)äº¤æ›¿
   - å¥½ç¤ºä¾‹ï¼š"å…‰å½±äº¤ç»‡ã€‚æ•°æ®åœ¨äº‘ç«¯æµè½¬ï¼Œæ™ºæ…§åœ¨æŒ‡å°–ç»½æ”¾ã€‚"ï¼ˆ17å­—ï¼‰
   - å¥½ç¤ºä¾‹ï¼š"è¿™æ˜¯å¼€å§‹ã€‚å½“ç¬¬ä¸€è¡Œä»£ç è¿è¡Œï¼Œæœªæ¥å°±åœ¨çœ¼å‰ã€‚"ï¼ˆ18å­—ï¼‰
   - å·®ç¤ºä¾‹ï¼š"ç ´ç¢å‡è§†ï¼Œæ•°æ®æ¶ŒåŠ¨ï¼Œæ™ºæ…§è§‰é†’ï¼Œæœªæ¥å¯æœŸã€‚"ï¼ˆ16å­—ï¼Œå…¨æ˜¯å››å­—ï¼‰
3. **è¿è´¯é€’è¿›**ï¼šä¸å‰æ–‡{"è‡ªç„¶è¡”æ¥" if previous_narrations else "éœ‡æ’¼å¼€åœº"}ï¼Œæƒ…æ„Ÿé€æ­¥{narration_framework.get('emotion_arc', 'é€’è¿›') if narration_framework else 'é€’è¿›'}
4. **æœ‰æ„ŸæŸ“åŠ›**ï¼šä½¿ç”¨å…·ä½“æ„è±¡ã€åŠ¨è¯å’Œç»†èŠ‚ï¼Œé¿å…ç©ºæ´å½¢å®¹è¯
5. **çº¯æ–‡æœ¬**ï¼šä¸è¦markdownç¬¦å·ï¼Œç›´æ¥è¾“å‡ºæ–‡æ¡ˆ

ã€åˆ›ä½œè§„èŒƒã€‘
- å¿…é¡»è‡³å°‘åŒ…å«ä¸€ä¸ªé•¿å¥ï¼ˆâ‰¥8å­—ï¼‰ï¼Œä¸èƒ½å…¨æ˜¯çŸ­å¥
- ä½¿ç”¨æ¯”å–»ã€æ’æ¯”ç­‰ä¿®è¾ï¼ˆä½†ä¸è¦è¿‡åº¦ï¼‰
- è‡ªç„¶å£è¯­åŒ–ï¼ŒåƒçœŸäººåœ¨è®²å¹¿å‘Šæ•…äº‹
- {"ç»“å°¾è¦æœ‰å‡åå’Œä½™å‘³ï¼Œå¯ç”¨ç–‘é—®æˆ–å·å¬" if i == config['shot_count'] - 1 else "ä¸ºä¸‹ä¸€é•œå¤´åŸ‹ä¸‹ä¼ç¬”"}

è¯·ç›´æ¥è¾“å‡º{target_chars}å­—çš„æ—ç™½æ–‡æ¡ˆï¼š"""

                try:
                    # è°ƒç”¨DeepSeekç”Ÿæˆæ—ç™½
                    deepseek_limiter.acquire()
                    narration_response = requests.post(url, headers=headers, json={
                        "model": "deepseek-chat",
                        "messages": [{"role": "user", "content": narration_prompt}],
                        "temperature": 0.75
                    }, timeout=60)
                    narration_response.raise_for_status()
                    narration_result = narration_response.json()
                    narration_text = narration_result['choices'][0]['message']['content'].strip()

                    # æ¸…ç†æ–‡æœ¬
                    narration_text = narration_text.strip('"').strip("'").strip()
                    if '\n' in narration_text:
                        narration_text = narration_text.split('\n')[0]
                    narration_text = narration_text.replace('*', '').replace('_', '').replace('#', '').replace('`', '').strip()

                    # éªŒè¯å­—æ•°ï¼ˆå®½å®¹èŒƒå›´ï¼‰
                    char_count = len(narration_text)
                    if char_count > max_chars:
                        log(f"   âš ï¸  æ—ç™½å­—æ•°è¶…é™({char_count}>{max_chars})ï¼Œæˆªæ–­", "WARN")
                        narration_text = narration_text[:max_chars]
                        char_count = len(narration_text)

                    # ä¼°ç®—æ—¶é•¿ï¼ˆä¸å†é€é•œå¤´TTSï¼‰ï¼Œä»…ä½œä¸ºå‚è€ƒæ—¥å¿—
                    approx_duration = char_count / CHARS_PER_SECOND
                    duration_diff = abs(approx_duration - shot_duration)
                    tolerance = shot_duration * 0.15  # 15%å®¹å·®

                    if duration_diff <= tolerance:
                        log(f"   âœ… æ—ç™½é¢„ä¼°åˆæ ¼: {char_count}å­—, çº¦{approx_duration:.2f}s (ç›®æ ‡{shot_duration}s, è¯¯å·®{duration_diff:.2f}s)")
                        break  # æˆåŠŸï¼Œè·³å‡ºé‡è¯•å¾ªç¯
                    else:
                        log(f"   âš ï¸  æ—ç™½é¢„ä¼°åå·®: {approx_duration:.2f}s (ç›®æ ‡{shot_duration}s, è¯¯å·®{duration_diff:.2f}s)", "WARN")
                        if attempt < max_retries:
                            continue  # é‡è¯•
                        else:
                            log(f"   âš ï¸  å·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œä½¿ç”¨å½“å‰ç‰ˆæœ¬", "WARN")
                            break

                except Exception as e:
                    log(f"   âŒ æ—ç™½ç”Ÿæˆå¤±è´¥ (å°è¯•{attempt+1}/{max_retries+1}): {e}", "ERROR")
                    if attempt == max_retries:
                        # æœ€åä¸€æ¬¡å¤±è´¥ï¼Œä½¿ç”¨å›é€€æ–¹æ¡ˆ
                        narration_text = beat['scene_summary'][:target_chars]
                        narration_text = narration_text.replace('*', '').replace('_', '').replace('#', '').replace('`', '').strip()
                        log(f"   ğŸ”„ ä½¿ç”¨å›é€€æ–¹æ¡ˆ: {narration_text}", "WARN")
                        break

            # å¦‚æœæ‰€æœ‰å°è¯•éƒ½å¤±è´¥
            if narration_text is None:
                narration_text = beat['scene_summary'][:target_chars]
                narration_text = narration_text.replace('*', '').replace('_', '').replace('#', '').replace('`', '').strip()

            # è®°å½•å½“å‰æ—ç™½ï¼Œä¾›åç»­é•œå¤´å‚è€ƒ
            previous_narrations.append(narration_text)

            shots.append({
                'id': beat['shot_number'],
                'summary_cn': beat['scene_summary'],
                'description': shot_prompt,
                'narration': narration_text,
                'visual_continuity': {
                    'from_previous': prev_beat['key_action'] if prev_beat else None,
                    'to_next': beat.get('transition_to_next')
                }
            })

            log(f"   âœ“ é•œå¤´ {i+1} å®Œæˆ:")
            log(f"      åœºæ™¯: {beat['scene_summary']}")
            log(f"      æ—ç™½: {narration_text}")
            log(f"      Prompt: {shot_prompt[:80]}...")
            log("")

        except Exception as e:
            log(f"   âŒ é•œå¤´ {i+1} ç”Ÿæˆå¤±è´¥ï¼š{e}", "ERROR")
            raise

    shots_data = {'shots': shots}

    # ä¿å­˜åˆ†é•œè„šæœ¬
    script_file = WORK_DIR / '22_shots_script.json'
    with open(script_file, 'w', encoding='utf-8') as f:
        json.dump(shots_data, f, indent=2, ensure_ascii=False)

    log("")
    log(f"âœ… è¿è´¯åˆ†é•œè„šæœ¬å·²ç”Ÿæˆï¼š{script_file}")
    log(f"   å…± {len(shots)} ä¸ªé•œå¤´")
    log("")

    # æ€»ç»“æ˜¾ç¤ºæ‰€æœ‰é•œå¤´
    log("ğŸ“‹ å®Œæ•´é•œå¤´åˆ—è¡¨:")
    for shot in shots:
        log(f"   é•œå¤´ {shot['id']}: {shot['summary_cn']}")

    log("-" * 60)

    return shots_data

def generate_shots_script(config=None):
    """ä½¿ç”¨DeepSeek APIç”Ÿæˆé•œå¤´è„šæœ¬ï¼ˆæ”¯æŒæ•…äº‹åŒ–ï¼‰

    Args:
        config: dict, å¯é€‰ã€‚å¦‚æœæä¾›åˆ™ä½¿ç”¨æ•…äº‹åŒ–ç”Ÿæˆï¼Œå¦åˆ™ä½¿ç”¨æ—§ç‰ˆæœ¬

    Returns:
        dict: shots_dataå­—å…¸
    """
    if config is not None:
        # æ–°ç‰ˆæœ¬ï¼šæ•…äº‹åŒ–ç”Ÿæˆï¼ˆä¸‰é˜¶æ®µï¼‰
        log("=" * 60)
        log("ğŸ“š æ•…äº‹åŒ–ç”Ÿæˆæ¨¡å¼ï¼ˆå·²å‡çº§ï¼šæ•´ä½“æ¡†æ¶ + ç²¾ç¡®æ—¶é•¿åŒ¹é…ï¼‰")
        log("=" * 60)

        # ç¬¬ä¸€é˜¶æ®µï¼šç”Ÿæˆæ•…äº‹å¤§çº²
        outline = generate_story_outline(config)

        # ç¬¬äºŒé˜¶æ®µï¼šç”Ÿæˆå¹¿å‘Šè¯æ¡†æ¶ï¼ˆæ–°å¢ï¼ï¼‰
        narration_framework = generate_narration_framework(outline, config)

        # ç¬¬ä¸‰é˜¶æ®µï¼šåŸºäºå¤§çº²å’Œæ¡†æ¶ç”Ÿæˆè¿è´¯åˆ†é•œ
        shots_data = generate_coherent_shots(outline, config, narration_framework)

        return shots_data

    # å…¼å®¹æ—§ç‰ˆæœ¬ï¼šç›´æ¥ç”Ÿæˆ3ä¸ªç‹¬ç«‹é•œå¤´
    log("-" * 30)
    log("ğŸ“ æ­£åœ¨ç”Ÿæˆé•œå¤´è„šæœ¬ï¼ˆç®€å•æ¨¡å¼ï¼‰...")

    url = "https://api.deepseek.com/v1/chat/completions"
    headers = {
        "Authorization": f"Bearer {DEEPSEEK_API_KEY}",
        "Content-Type": "application/json"
    }

    prompt = """è¯·ä¸º"Akamaiæ¨å‡ºAIæ¨ç†äº‘"ç”Ÿæˆ3ä¸ªè§†é¢‘å¹¿å‘Šé•œå¤´çš„æè¿°ã€‚æ¯ä¸ªé•œå¤´3ç§’ã€‚
è¦æ±‚ï¼š
1. ç§‘æŠ€æ„Ÿ/æœªæ¥é£æ ¼
2. ä½¿ç”¨ç§‘æŠ€å…ƒç´ ï¼šæ•°æ®æµã€å…¨æ¯æŠ•å½±ã€èŠ¯ç‰‡ã€æœåŠ¡å™¨ã€äº‘è®¡ç®—å¯è§†åŒ–
3. è‰²è°ƒï¼šè“è‰²ã€ç´«è‰²ã€éœ“è™¹è‰²
4. æ¯ä¸ªé•œå¤´è¦æœ‰æ¸…æ™°çš„è§†è§‰æè¿°

è¯·ä»¥JSONæ ¼å¼è¿”å›ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
{
  "shots": [
    {"id": 1, "description": "é•œå¤´1çš„è¯¦ç»†è‹±æ–‡promptæè¿°"},
    {"id": 2, "description": "é•œå¤´2çš„è¯¦ç»†è‹±æ–‡promptæè¿°"},
    {"id": 3, "description": "é•œå¤´3çš„è¯¦ç»†è‹±æ–‡promptæè¿°"}
  ]
}
"""

    payload = {
        "model": "deepseek-chat",
        "messages": [
            {"role": "user", "content": prompt}
        ],
        "temperature": 0.7
    }

    try:
        # APIé™æµæ§åˆ¶
        deepseek_limiter.acquire()
        response = requests.post(url, headers=headers, json=payload, timeout=30)
        response.raise_for_status()
        result = response.json()
        content = result['choices'][0]['message']['content']

        # æå–JSONéƒ¨åˆ†
        if '```json' in content:
            content = content.split('```json')[1].split('```')[0].strip()
        elif '```' in content:
            content = content.split('```')[1].split('```')[0].strip()

        shots_data = json.loads(content)

        # ä¿å­˜è„šæœ¬
        script_file = WORK_DIR / '22_shots_script.json'
        with open(script_file, 'w', encoding='utf-8') as f:
            json.dump(shots_data, f, indent=2, ensure_ascii=False)

        log(f"âœ… é•œå¤´è„šæœ¬å·²ç”Ÿæˆï¼š{script_file}")
        log(f"   å…± {len(shots_data['shots'])} ä¸ªé•œå¤´")
        log("")

        # è¯¦ç»†æ˜¾ç¤ºæ¯ä¸ªé•œå¤´çš„æè¿°
        log("ğŸ“‹ é•œå¤´è„šæœ¬è¯¦æƒ…:")
        for shot in shots_data['shots']:
            log(f"   é•œå¤´ {shot['id']}:")
            log(f"      Prompt: {shot['description']}")
            log("")

        log("-" * 30)
        return shots_data

    except Exception as e:
        log(f"âŒ ç”Ÿæˆè„šæœ¬å¤±è´¥ï¼š{e}", "ERROR")
        raise

def condense_narration_text(original_text, target_duration, current_duration, max_retries=3):
    """ä½¿ç”¨DeepSeekç²¾ç®€æ–‡æ¡ˆï¼Œä½¿å…¶é€‚é…ç›®æ ‡æ—¶é•¿

    Args:
        original_text: åŸå§‹æ–‡æ¡ˆ
        target_duration: ç›®æ ‡æ—¶é•¿ï¼ˆç§’ï¼‰
        current_duration: å½“å‰é…éŸ³æ—¶é•¿ï¼ˆç§’ï¼‰
        max_retries: æœ€å¤§é‡è¯•æ¬¡æ•°

    Returns:
        str: ç²¾ç®€åçš„æ–‡æ¡ˆï¼Œå¦‚æœå¤±è´¥åˆ™è¿”å›None
    """
    # è®¡ç®—å‹ç¼©æ¯”ä¾‹
    compression_ratio = target_duration / current_duration
    original_chars = len(original_text)
    target_chars = int(original_chars * compression_ratio * 0.9)  # ä¿å®ˆä¼°è®¡ï¼Œç•™10%ä½™é‡

    log(f"   ğŸ“‰ éœ€è¦ç²¾ç®€æ–‡æ¡ˆ:")
    log(f"      åŸæ–‡: {original_chars}å­—, {current_duration:.2f}ç§’")
    log(f"      ç›®æ ‡: {target_chars}å­—å·¦å³, {target_duration:.2f}ç§’")

    url = "https://api.deepseek.com/v1/chat/completions"
    headers = {
        "Authorization": f"Bearer {DEEPSEEK_API_KEY}",
        "Content-Type": "application/json"
    }

    prompt = f"""è¯·ç²¾ç®€ä»¥ä¸‹å¹¿å‘Šæ–‡æ¡ˆï¼Œä¿ç•™æ ¸å¿ƒä¿¡æ¯å’Œæ„ŸæŸ“åŠ›ï¼š

åŸæ–‡ï¼ˆ{original_chars}å­—ï¼‰ï¼š
{original_text}

è¦æ±‚ï¼š
1. **å­—æ•°**: ä¸¥æ ¼æ§åˆ¶åœ¨{target_chars}å­—å·¦å³ï¼ˆÂ±5å­—ï¼‰
2. **ä¿ç•™**: æ ¸å¿ƒä¿¡æ¯ã€æƒ…æ„ŸåŸºè°ƒã€ä¿®è¾æ‰‹æ³•
3. **åˆ å‡**: é‡å¤å†…å®¹ã€è¿‡åº¦ä¿®é¥°ã€ä¸å¿…è¦çš„ç»†èŠ‚
4. **é£æ ¼**: ä¿æŒåŸæœ‰çš„è¯­è¨€é£æ ¼å’ŒèŠ‚å¥æ„Ÿ
5. **æµç•…**: ç²¾ç®€åä¾ç„¶é€šé¡ºè‡ªç„¶ï¼Œä¸ç”Ÿç¡¬

è¯·ç›´æ¥è¾“å‡ºç²¾ç®€åçš„æ–‡æ¡ˆï¼Œä¸è¦å…¶ä»–å†…å®¹ï¼š"""

    payload = {
        "model": "deepseek-chat",
        "messages": [{"role": "user", "content": prompt}],
        "temperature": 0.5  # è¾ƒä½æ¸©åº¦ï¼Œä¿è¯è´¨é‡
    }

    for attempt in range(max_retries):
        try:
            log(f"   ğŸ”„ DeepSeekç²¾ç®€æ–‡æ¡ˆ (å°è¯• {attempt + 1}/{max_retries})...")
            deepseek_limiter.acquire()
            response = requests.post(url, headers=headers, json=payload, timeout=60)
            response.raise_for_status()
            result = response.json()

            condensed_text = result['choices'][0]['message']['content'].strip()
            # æ¸…ç†æ–‡æœ¬
            condensed_text = condensed_text.strip('"').strip("'").strip()
            if '\n' in condensed_text:
                condensed_text = condensed_text.split('\n')[0]

            condensed_chars = len(condensed_text)
            log(f"   âœ… ç²¾ç®€å®Œæˆ: {condensed_chars}å­—")
            log(f"      ç²¾ç®€å: {condensed_text}")

            return condensed_text

        except Exception as e:
            log(f"   âš ï¸  ç²¾ç®€å¤±è´¥ (å°è¯• {attempt + 1}/{max_retries}): {e}", "WARN")
            if attempt == max_retries - 1:
                log(f"   âŒ è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œç²¾ç®€å¤±è´¥", "ERROR")
                return None
            time.sleep(2)  # çŸ­æš‚ç­‰å¾…åé‡è¯•

    return None

def generate_images_parallel(shots, shot_count, character_image_path=None):
    """å¹¶å‘ç”Ÿæˆæ‰€æœ‰å›¾åƒ

    Args:
        shots: å¾…å¤„ç†çš„é•œå¤´åˆ—è¡¨
        shot_count: æ€»é•œå¤´æ•°
        character_image_path: ä¸»è§’å‚è€ƒå›¾è·¯å¾„ï¼ˆå¯é€‰ï¼‰

    Returns:
        dict: {shot_id: image_url} æ˜ å°„å­—å…¸
    """
    if not shots:
        return {}

    log(f"ğŸ¨ å¹¶å‘ç”Ÿæˆ {len(shots)} ä¸ªå›¾åƒï¼ˆåŠ é€Ÿç”Ÿæˆï¼‰...")
    max_workers = min(MAX_CONCURRENT_WORKERS, len(shots))
    log(f"   å¹¶å‘æ•°: {max_workers}")

    results = {}
    failed = []

    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        # æäº¤æ‰€æœ‰ä»»åŠ¡
        future_to_shot = {
            executor.submit(generate_image, shot['description'], shot['id'], shot_count, character_image_path): shot
            for shot in shots
        }

        # æ”¶é›†ç»“æœ
        for future in as_completed(future_to_shot):
            shot = future_to_shot[future]
            try:
                image_url = future.result()
                results[shot['id']] = image_url
                log(f"   âœ… é•œå¤´ {shot['id']} å›¾åƒç”Ÿæˆå®Œæˆ ({len(results)}/{len(shots)})")
            except Exception as e:
                failed.append((shot['id'], str(e)))
                log(f"   âŒ é•œå¤´ {shot['id']} å›¾åƒç”Ÿæˆå¤±è´¥: {e}", "ERROR")

    if failed:
        log(f"âš ï¸  {len(failed)} ä¸ªå›¾åƒç”Ÿæˆå¤±è´¥ï¼Œè¿™äº›é•œå¤´å°†è¢«è·³è¿‡", "WARN")

    log(f"âœ… å›¾åƒç”Ÿæˆå®Œæˆ: {len(results)}/{len(shots)} æˆåŠŸ")
    return results

def generate_videos_parallel(shots_with_images, shot_count, resolution="720p"):
    """å¹¶å‘ç”Ÿæˆæ‰€æœ‰è§†é¢‘ï¼ˆæ”¯æŒ429é”™è¯¯é‡è¯•ï¼‰

    Args:
        shots_with_images: åˆ—è¡¨ï¼Œæ¯ä¸ªå…ƒç´ ä¸º (shot, image_url) æˆ– (shot, None)
        shot_count: æ€»é•œå¤´æ•°
        resolution: è§†é¢‘åˆ†è¾¨ç‡ï¼Œé»˜è®¤720p

    Returns:
        dict: {shot_id: video_file} æˆåŠŸç”Ÿæˆçš„è§†é¢‘æ˜ å°„
        list: [(shot_id, error)] å¤±è´¥çš„é•œå¤´åˆ—è¡¨
    """
    if not shots_with_images:
        return {}, []

    log(f"ğŸ¬ å¹¶å‘ç”Ÿæˆ {len(shots_with_images)} ä¸ªè§†é¢‘...")
    max_workers = min(MAX_CONCURRENT_WORKERS, len(shots_with_images))
    log(f"   å¹¶å‘æ•°: {max_workers}")
    log(f"   âš ï¸  æ³¨æ„: å¦‚é‡429é™æµé”™è¯¯ï¼Œå°†è‡ªåŠ¨é‡è¯•")

    results = {}
    failed = []

    def generate_video_with_retry(shot, image_url, max_retries=3):
        """ç”Ÿæˆè§†é¢‘ï¼Œæ”¯æŒ429é”™è¯¯é‡è¯•"""
        last_error = None
        for attempt in range(1, max_retries + 1):
            try:
                video_file = generate_video(image_url, shot['description'], shot['id'], shot_count, resolution)
                return shot['id'], video_file, None
            except requests.exceptions.HTTPError as e:
                # æ£€æŸ¥æ˜¯å¦æ˜¯429é”™è¯¯
                if e.response.status_code == 429:
                    last_error = e
                    if attempt < max_retries:
                        wait_time = 10 * attempt  # æ¸è¿›å¼ç­‰å¾…ï¼š10s, 20s, 30s
                        log(f"   âš ï¸  é•œå¤´{shot['id']} è§¦å‘é™æµ(429)ï¼Œ{wait_time}ç§’åé‡è¯• (å°è¯•{attempt}/{max_retries})", "WARN")
                        time.sleep(wait_time)
                    else:
                        log(f"   âŒ é•œå¤´{shot['id']} è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°", "ERROR")
                else:
                    # å…¶ä»–HTTPé”™è¯¯ï¼Œä¸é‡è¯•
                    return shot['id'], None, str(e)
            except Exception as e:
                # å…¶ä»–é”™è¯¯ï¼Œä¸é‡è¯•
                return shot['id'], None, str(e)

        return shot['id'], None, f"429é”™è¯¯ï¼Œå·²é‡è¯•{max_retries}æ¬¡: {last_error}"

    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        # æäº¤æ‰€æœ‰ä»»åŠ¡
        future_to_shot = {
            executor.submit(generate_video_with_retry, shot, image_url): shot
            for shot, image_url in shots_with_images
        }

        # æ”¶é›†ç»“æœ
        for future in as_completed(future_to_shot):
            shot = future_to_shot[future]
            try:
                shot_id, video_file, error = future.result()

                if video_file:
                    results[shot_id] = video_file
                    log(f"   âœ… é•œå¤´ {shot_id} è§†é¢‘ç”Ÿæˆå®Œæˆ ({len(results)}/{len(shots_with_images)})")
                else:
                    failed.append((shot_id, error))
                    log(f"   âŒ é•œå¤´ {shot_id} è§†é¢‘ç”Ÿæˆå¤±è´¥: {error}", "ERROR")
            except Exception as e:
                failed.append((shot['id'], str(e)))
                log(f"   âŒ é•œå¤´ {shot['id']} å¼‚å¸¸: {e}", "ERROR")

    if failed:
        log(f"âš ï¸  {len(failed)} ä¸ªè§†é¢‘ç”Ÿæˆå¤±è´¥", "WARN")

    log(f"âœ… è§†é¢‘ç”Ÿæˆå®Œæˆ: {len(results)}/{len(shots_with_images)} æˆåŠŸ")
    return results, failed

def upload_image_to_cloudinary(image_source):
    """ä¸Šä¼ å›¾ç‰‡åˆ°å›¾åºŠå¹¶è·å–URLï¼Œæ”¯æŒæœ¬åœ°æ–‡ä»¶/URL

    Args:
        image_source: æœ¬åœ°å›¾ç‰‡è·¯å¾„æˆ–å…¬ç½‘URL

    Returns:
        str: ä¸Šä¼ åçš„å›¾ç‰‡URL
    """
    import base64
    import requests

    # ä½¿ç”¨å…è´¹çš„imgbbå›¾åºŠAPI
    # æ³¨å†Œåœ°å€: https://api.imgbb.com/
    # è¿™é‡Œä½¿ç”¨å…¬å…±æµ‹è¯•keyï¼ˆç”Ÿäº§ç¯å¢ƒåº”è¯¥ä½¿ç”¨è‡ªå·±çš„keyï¼‰

    # è¯»å–å›¾ç‰‡å¹¶è½¬æ¢ä¸ºbase64
    if isinstance(image_source, str) and image_source.startswith(('http://', 'https://')):
        # ç›´æ¥æ‹‰å–è¿œç¨‹å›¾ç‰‡ï¼Œå†ä¸Šä¼ ï¼Œé¿å…ç¬¬ä¸‰æ–¹APIæ— æ³•è®¿é—®åŸURL
        resp = requests.get(image_source, timeout=30)
        resp.raise_for_status()
        image_data = resp.content
    else:
        with open(image_source, 'rb') as f:
            image_data = f.read()

    base64_image = base64.b64encode(image_data).decode('utf-8')

    # ä¸Šä¼ åˆ°imgbb (å…è´¹å…¬å…±å›¾åºŠ)
    url = "https://api.imgbb.com/1/upload"
    params = {
        "key": "d139be0b91a49610f8c8b2a5c07d3cd7"  # å…¬å…±æµ‹è¯•key
    }

    payload = {
        "image": base64_image
    }

    response = requests.post(url, params=params, data=payload, timeout=60)
    response.raise_for_status()
    result = response.json()

    # æå–URL
    if result.get('success') and 'data' in result:
        return result['data']['url']
    else:
        raise ValueError(f"ä¸Šä¼ å¤±è´¥: {result.get('error', {}).get('message', 'Unknown error')}")

@smart_retry(max_attempts=3, backoff_factor=2)
def generate_image(prompt, shot_id, shot_count, character_image_path=None):
    """ä½¿ç”¨é…ç½®çš„æ¨¡å‹ç”Ÿæˆå›¾åƒï¼ˆæ”¯æŒå‚è€ƒå›¾ï¼‰

    Args:
        prompt: æ–‡æœ¬æç¤ºè¯
        shot_id: é•œå¤´ID
        shot_count: æ€»é•œå¤´æ•°
        character_image_path: ä¸»è§’å‚è€ƒå›¾è·¯å¾„ï¼ˆå¯é€‰ï¼‰

    Returns:
        str: å›¾åƒURLï¼ˆå…¬ç½‘å¯è®¿é—®ï¼‰
    """
    model_config = IMAGE_MODEL_CONFIG[CURRENT_IMAGE_MODEL]

    api_cost = model_config['cost']

    log("-" * 30)
    log(f"ğŸ¨ æ­£åœ¨ç”Ÿæˆé•œå¤´ {shot_id}/{shot_count} çš„å›¾åƒ...")
    log(f"   æ¨¡å‹: {CURRENT_IMAGE_MODEL} (æˆæœ¬${api_cost}, è´¨é‡:{model_config['quality']})")
    log(f"   æç¤ºè¯: {prompt[:80]}...")

    # æ£€æŸ¥æ˜¯å¦æ”¯æŒå‚è€ƒå›¾
    support_reference = model_config.get('support_reference', False)
    if character_image_path and support_reference:
        log(f"   ğŸ“· ä½¿ç”¨å‚è€ƒå›¾: {Path(character_image_path).name}")
    elif character_image_path and not support_reference:
        log(f"   âš ï¸  å½“å‰æ¨¡å‹ä¸æ”¯æŒå‚è€ƒå›¾ï¼Œå°†å¿½ç•¥å‚è€ƒå›¾", "WARN")

    # æŸ¥è¯¢è°ƒç”¨å‰ä½™é¢
    before_balance = get_wavespeed_balance()
    if before_balance is not None:
        log(f"   ğŸ’° è°ƒç”¨å‰ä½™é¢: ${before_balance:.4f}")

    url = f"https://api.wavespeed.ai{model_config['endpoint']}"
    headers = {
        "Authorization": f"Bearer {WAVESPEED_API_KEY}",
        "Content-Type": "application/json"
    }

    # åˆå¹¶æç¤ºè¯å’Œæ¨¡å‹ç‰¹å®šå‚æ•°
    payload = {"prompt": prompt}
    payload.update(model_config['params'])

    # å¦‚æœæ¨¡å‹æ”¯æŒå‚è€ƒå›¾ä¸”æä¾›äº†å‚è€ƒå›¾ï¼Œåˆ™å¤„ç†å‚è€ƒå›¾URL
    if support_reference and character_image_path:
        try:
            # å¦‚æœæ˜¯å…¬ç½‘URLï¼Œç›´æ¥ä½¿ç”¨ï¼ˆä¸éœ€è¦é‡æ–°ä¸Šä¼ ï¼‰
            if character_image_path.startswith(('http://', 'https://')):
                log(f"   ğŸ”— ä½¿ç”¨å‚è€ƒå›¾URLï¼ˆç›´æ¥å¼•ç”¨ï¼‰")
                reference_image_url = character_image_path
            else:
                # æœ¬åœ°æ–‡ä»¶éœ€è¦ä¸Šä¼ åˆ°å›¾åºŠ
                if not Path(character_image_path).exists():
                    raise FileNotFoundError(f"å‚è€ƒå›¾ä¸å­˜åœ¨: {character_image_path}")
                log(f"   ğŸ“¤ ä¸Šä¼ æœ¬åœ°å‚è€ƒå›¾åˆ°å›¾åºŠ...")
                reference_image_url = upload_image_to_cloudinary(character_image_path)
                log(f"   âœ“ å‚è€ƒå›¾å·²ä¸Šä¼ : {reference_image_url[:70]}...")

            payload['images'] = [reference_image_url]
        except Exception as e:
            log(f"   âš ï¸  å‚è€ƒå›¾å¤„ç†å¤±è´¥: {e}ï¼Œå°†ä½¿ç”¨çº¯æ–‡æœ¬æ¨¡å¼", "WARN")

    log(f"   ğŸ“¤ æäº¤å›¾åƒç”Ÿæˆä»»åŠ¡...")
    # APIé™æµæ§åˆ¶
    image_limiter.acquire()
    response = requests.post(url, headers=headers, json=payload, timeout=60)
    response.raise_for_status()
    raw_result = response.json()

    # ç»Ÿä¸€è§£æå“åº”æ ¼å¼
    result = parse_api_response(raw_result, f"å›¾åƒç”Ÿæˆ-{CURRENT_IMAGE_MODEL}")

    # æå–å¹¶éªŒè¯ä»»åŠ¡ID
    task_id = result.get('id')
    validate_task_id(task_id, "å›¾åƒç”Ÿæˆä»»åŠ¡")

    log(f"   âœ“ ä»»åŠ¡å·²æäº¤ï¼ŒID: {task_id}")
    log(f"   â³ é¢„è®¡ç­‰å¾…æ—¶é—´: 10-30ç§’")

    # ç­‰å¾…å›¾åƒç”Ÿæˆ
    image_url = wait_for_result(task_id, "å›¾åƒ", max_wait=120)

    # ä¸‹è½½å›¾åƒï¼ˆä¿å­˜åˆ°æœ¬åœ°ç”¨äºæŸ¥çœ‹ï¼‰
    log(f"   ğŸ“¥ æ­£åœ¨ä¸‹è½½å›¾åƒ...")
    image_num = 30 + (shot_id - 1)
    image_file = WORK_DIR / f'{image_num:02d}_shot_{shot_id:02d}_image.png'
    download_file(image_url, image_file)

    file_size = image_file.stat().st_size / (1024 * 1024)
    log(f"âœ… é•œå¤´ {shot_id}/{shot_count} å›¾åƒå·²ç”Ÿæˆ")
    log(f"   æœ¬åœ°æ–‡ä»¶: {image_file}")
    log(f"   å›¾åƒURL: {image_url}")
    log(f"   æ–‡ä»¶å¤§å°: {file_size:.2f} MB")

    # æŸ¥è¯¢è°ƒç”¨åä½™é¢å¹¶æ˜¾ç¤º
    after_balance = get_wavespeed_balance()
    if before_balance is not None and after_balance is not None:
        display_balance(before_balance, after_balance, api_cost, f"å›¾åƒç”Ÿæˆ (é•œå¤´{shot_id})")

    log("-" * 30)

    # è¿”å›å…¬ç½‘URLï¼Œä¾›I2Vä½¿ç”¨
    return image_url

@smart_retry(max_attempts=3, backoff_factor=2)
def generate_video(image_url, prompt, shot_id, shot_count, resolution="720p"):
    """ä½¿ç”¨é…ç½®çš„æ¨¡å‹ç”Ÿæˆè§†é¢‘ï¼ˆç¬¬äºŒæ­¥ï¼šå›¾åƒç”Ÿæˆè§†é¢‘ æˆ– ç›´æ¥æ–‡æœ¬ç”Ÿæˆè§†é¢‘ï¼‰

    Args:
        image_url: å›¾åƒçš„å…¬ç½‘URLï¼ˆI2Væ—¶ä½¿ç”¨ï¼‰æˆ– Noneï¼ˆT2Væ—¶ï¼‰
        prompt: åŸå§‹æç¤ºè¯
        shot_id: é•œå¤´ID
        shot_count: æ€»é•œå¤´æ•°
        resolution: è§†é¢‘åˆ†è¾¨ç‡ï¼Œé»˜è®¤720p
    """
    model_config = VIDEO_MODEL_CONFIG[CURRENT_VIDEO_MODEL]
    api_cost = get_video_cost(CURRENT_VIDEO_MODEL, resolution)

    log("-" * 30)
    log(f"ğŸ¬ æ­£åœ¨ç”Ÿæˆé•œå¤´ {shot_id}/{shot_count} çš„è§†é¢‘...")
    log(f"   æ¨¡å‹: {CURRENT_VIDEO_MODEL} (æˆæœ¬${api_cost}, é¢„è®¡{model_config['speed']})")
    log(f"   åˆ†è¾¨ç‡: {resolution}")

    # æŸ¥è¯¢è°ƒç”¨å‰ä½™é¢
    before_balance = get_wavespeed_balance()
    if before_balance is not None:
        log(f"   ğŸ’° è°ƒç”¨å‰ä½™é¢: ${before_balance:.4f}")

    url = f"https://api.wavespeed.ai{model_config['endpoint']}"
    headers = {
        "Authorization": f"Bearer {WAVESPEED_API_KEY}",
        "Content-Type": "application/json"
    }

    # æ ¹æ®æ¨¡å‹ç±»å‹æ„å»ºpayload
    if model_config['type'] == 'i2v':
        log(f"   è¾“å…¥å›¾åƒURL: {image_url[:80]}...")
        payload = {
            "image": image_url,
            "prompt": "Camera movement with smooth motion, cinematic feel",
            "resolution": resolution,
            "duration": 5,
            "enable_prompt_expansion": False,
            "seed": -1
        }
    else:  # t2v
        log(f"   æç¤ºè¯: {prompt[:80]}...")
        payload = {
            "prompt": prompt,
            "resolution": resolution,
            "duration": 5,
            "enable_prompt_expansion": False,
            "seed": -1
        }

    log(f"   ğŸ“¤ æäº¤è§†é¢‘ç”Ÿæˆä»»åŠ¡...")
    # APIé™æµæ§åˆ¶
    video_limiter.acquire()
    response = requests.post(url, headers=headers, json=payload, timeout=60)
    response.raise_for_status()
    raw_result = response.json()

    # ç»Ÿä¸€è§£æå“åº”æ ¼å¼
    result = parse_api_response(raw_result, f"è§†é¢‘ç”Ÿæˆ-{CURRENT_VIDEO_MODEL}")

    # æå–å¹¶éªŒè¯ä»»åŠ¡ID
    task_id = result.get('id')
    validate_task_id(task_id, "è§†é¢‘ç”Ÿæˆä»»åŠ¡")

    log(f"   âœ“ ä»»åŠ¡å·²æäº¤ï¼ŒID: {task_id}")
    log(f"   â³ é¢„è®¡ç­‰å¾…æ—¶é—´: 2-3åˆ†é’Ÿ")

    # è½®è¯¢ç­‰å¾…ä»»åŠ¡å®Œæˆï¼ˆå¢åŠ è¶…æ—¶æ—¶é—´ï¼‰
    video_url = wait_for_result(task_id, "è§†é¢‘", max_wait=600)

    # ä¸‹è½½è§†é¢‘
    log(f"   ğŸ“¥ æ­£åœ¨ä¸‹è½½è§†é¢‘...")
    video_num = 50 + (shot_id - 1)
    video_file = WORK_DIR / f'{video_num:02d}_shot_{shot_id:02d}.mp4'
    download_file(video_url, video_file)

    file_size = video_file.stat().st_size / (1024 * 1024)
    log(f"âœ… é•œå¤´ {shot_id}/{shot_count} è§†é¢‘å·²ç”Ÿæˆï¼š{video_file}")
    log(f"   æ–‡ä»¶å¤§å°: {file_size:.2f} MB")

    # æŸ¥è¯¢è°ƒç”¨åä½™é¢å¹¶æ˜¾ç¤º
    after_balance = get_wavespeed_balance()
    if before_balance is not None and after_balance is not None:
        display_balance(before_balance, after_balance, api_cost, f"è§†é¢‘ç”Ÿæˆ (é•œå¤´{shot_id})")

    show_progress_bar(shot_id, shot_count, "ğŸ“Š æ€»ä½“è¿›åº¦")
    log("-" * 30)
    return video_file

def generate_music():
    """ç”ŸæˆèƒŒæ™¯éŸ³ä¹ï¼ˆWAN 2.6æ”¯æŒéŸ³è§†é¢‘åŒæ­¥ï¼Œæ­¤å¤„è·³è¿‡å•ç‹¬éŸ³ä¹ç”Ÿæˆï¼‰"""
    print("ğŸµ èƒŒæ™¯éŸ³ä¹å°†åœ¨è§†é¢‘åˆæˆæ—¶æ·»åŠ ...")
    # WAN 2.6æ”¯æŒåŸç”ŸéŸ³è§†é¢‘åŒæ­¥ï¼Œä½†Hailuoä¸æ”¯æŒ
    # ä¸ºç®€åŒ–æµç¨‹ï¼Œæš‚æ—¶è·³è¿‡å•ç‹¬éŸ³ä¹ç”Ÿæˆï¼Œä½¿ç”¨æ— å£°è§†é¢‘
    return None

def download_file(url, filepath):
    """ä¸‹è½½æ–‡ä»¶"""
    response = requests.get(url, timeout=60)
    response.raise_for_status()
    with open(filepath, 'wb') as f:
        f.write(response.content)

def wait_for_result(task_id, result_type="è§†é¢‘", max_wait=600):
    """ç­‰å¾…ä»»åŠ¡å®Œæˆï¼ˆé€šç”¨å‡½æ•°ï¼Œæ”¯æŒå›¾åƒå’Œè§†é¢‘ï¼‰

    Args:
        task_id: ä»»åŠ¡ID
        result_type: ç»“æœç±»å‹ï¼ˆ"å›¾åƒ"æˆ–"è§†é¢‘"ï¼‰
        max_wait: æœ€å¤§ç­‰å¾…æ—¶é—´ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤600ç§’
    """
    url = f"https://api.wavespeed.ai/api/v3/predictions/{task_id}/result"
    headers = {"Authorization": f"Bearer {WAVESPEED_API_KEY}"}

    start_time = time.time()
    check_interval = 10  # æ¯10ç§’æ£€æŸ¥ä¸€æ¬¡
    retry_count = 0
    max_retries = 10  # æœ€å¤šé‡è¯•10æ¬¡ç½‘ç»œé”™è¯¯

    log(f"   â³ ç­‰å¾…{result_type}ç”Ÿæˆå®Œæˆ (ä»»åŠ¡ID: {task_id})...")

    while time.time() - start_time < max_wait:
        try:
            # å¢åŠ è¶…æ—¶æ—¶é—´åˆ°30ç§’
            response = requests.get(url, headers=headers, timeout=30)
            response.raise_for_status()
            raw_result = response.json()

            # é‡ç½®é‡è¯•è®¡æ•°
            retry_count = 0

            # ç»Ÿä¸€è§£æå“åº”æ ¼å¼
            try:
                result = parse_api_response(raw_result, f"æŸ¥è¯¢{result_type}çŠ¶æ€")
            except ValueError as e:
                # APIè¿”å›é”™è¯¯ï¼Œè®°å½•å¹¶ç»§ç»­é‡è¯•
                log(f"   âš ï¸  APIé”™è¯¯: {e}ï¼Œç»§ç»­ç­‰å¾…...", "WARN")
                time.sleep(check_interval)
                continue

            # æ£€æŸ¥ä»»åŠ¡çŠ¶æ€
            status = result.get('status')

            if status == 'completed':
                outputs = result.get('outputs', [])
                if not outputs:
                    raise TaskFailedError(f"{result_type}ç”Ÿæˆå®Œæˆä½†æ— è¾“å‡ºï¼Œå“åº”: {json.dumps(result, ensure_ascii=False)[:200]}")

                elapsed = int(time.time() - start_time)
                log(f"   âœ… ç”Ÿæˆå®Œæˆï¼ç”¨æ—¶ {elapsed} ç§’")
                return outputs[0]  # è¿”å›URL

            elif status == 'failed':
                error = result.get('error', 'æœªçŸ¥é”™è¯¯')
                raise TaskFailedError(f"{result_type}ç”Ÿæˆå¤±è´¥: {error}")

            # ç»§ç»­ç­‰å¾…
            elapsed = int(time.time() - start_time)
            remaining = max_wait - elapsed
            log(f"   â±ï¸  çŠ¶æ€: {status or 'processing'} | å·²ç­‰å¾…: {elapsed}s | å‰©ä½™: {remaining}s")

            # ç­‰å¾…ä¸‹æ¬¡æ£€æŸ¥
            time.sleep(check_interval)

        except requests.exceptions.RequestException as e:
            retry_count += 1
            if retry_count > max_retries:
                log(f"   âŒ ç½‘ç»œé”™è¯¯è¶…è¿‡æœ€å¤§é‡è¯•æ¬¡æ•° ({max_retries})", "ERROR")
                raise

            # æŒ‡æ•°é€€é¿
            wait_time = min(5 * retry_count, 30)  # æœ€å¤šç­‰å¾…30ç§’
            log(f"   âš ï¸  æŸ¥è¯¢å‡ºé”™ (é‡è¯• {retry_count}/{max_retries}): {e}ï¼Œ{wait_time}ç§’åé‡è¯•...", "WARN")
            time.sleep(wait_time)

    raise TimeoutError(f"{result_type}ç”Ÿæˆè¶…æ—¶ï¼ˆè¶…è¿‡{max_wait}ç§’ï¼‰")

def merge_videos(shot_count):
    """ä½¿ç”¨FFmpeg Concat Demuxeråˆå¹¶è§†é¢‘ç‰‡æ®µï¼ˆæ— æŸã€å¿«é€Ÿï¼‰"""
    log("ğŸï¸  æ­£åœ¨åˆæˆæœ€ç»ˆè§†é¢‘...")

    try:
        import subprocess
        import imageio_ffmpeg

        # è·å–ffmpegè·¯å¾„
        ffmpeg_bin = imageio_ffmpeg.get_ffmpeg_exe()
        log(f"   ğŸ”§ ä½¿ç”¨FFmpeg: {Path(ffmpeg_bin).name}")

        # æ£€æŸ¥è§†é¢‘æ–‡ä»¶
        video_files = []
        log(f"   ğŸ“‚ æ£€æŸ¥ {shot_count} ä¸ªé•œå¤´...")
        for i in range(1, shot_count + 1):
            video_num = 50 + (i - 1)
            video_file = WORK_DIR / f'{video_num:02d}_shot_{i:02d}.mp4'
            if video_file.exists():
                size_mb = video_file.stat().st_size / 1024 / 1024
                log(f"   âœ“ é•œå¤´ {i}/{shot_count}: {video_file.name} ({size_mb:.2f} MB)")
                video_files.append(video_file)
            else:
                log(f"   âš ï¸  é•œå¤´ {i} æ–‡ä»¶ä¸å­˜åœ¨: {video_file.name}", "WARN")

        if not video_files:
            raise ValueError("æ²¡æœ‰æ‰¾åˆ°ä»»ä½•è§†é¢‘æ–‡ä»¶")

        # åˆ›å»ºFFmpeg concatæ–‡ä»¶åˆ—è¡¨
        filelist_path = WORK_DIR / '85_filelist.txt'
        with open(filelist_path, 'w') as f:
            for vf in video_files:
                f.write(f"file '{vf.name}'\n")

        log(f"   ğŸ“ åˆ›å»ºæ–‡ä»¶åˆ—è¡¨: {filelist_path.name}")

        # è¾“å‡ºæ–‡ä»¶
        output_file = WORK_DIR / '90_final.mp4'

        # æ‰§è¡ŒFFmpegåˆæˆ
        log("   ğŸ”— æ­£åœ¨åˆæˆè§†é¢‘ (FFmpeg Concat Demuxer, Stream Copy)...")

        cmd = [
            ffmpeg_bin,
            "-f", "concat",
            "-safe", "0",
            "-i", "85_filelist.txt",
            "-c", "copy",  # stream copyï¼Œä¸é‡æ–°ç¼–ç ï¼Œä¿æŒåŸè´¨é‡
            "-y",
            "90_final.mp4"
        ]

        result = subprocess.run(
            cmd,
            cwd=str(WORK_DIR),
            capture_output=True,
            text=True,
            timeout=60
        )

        # æ¸…ç†ä¸´æ—¶æ–‡ä»¶åˆ—è¡¨
        if filelist_path.exists():
            filelist_path.unlink()

        if result.returncode != 0:
            raise RuntimeError(f"FFmpegæ‰§è¡Œå¤±è´¥: {result.stderr}")

        if not output_file.exists():
            raise RuntimeError("è¾“å‡ºæ–‡ä»¶æœªç”Ÿæˆ")

        # è¾“å‡ºç»Ÿè®¡ä¿¡æ¯
        output_size_mb = output_file.stat().st_size / 1024 / 1024
        total_input_size = sum(vf.stat().st_size for vf in video_files) / 1024 / 1024

        log(f"âœ… æœ€ç»ˆè§†é¢‘å·²ç”Ÿæˆï¼š{output_file.name}")
        log(f"   è¾“å…¥: {len(video_files)} ä¸ªè§†é¢‘ç‰‡æ®µ")
        log(f"   è¾“å…¥æ€»å¤§å°: {total_input_size:.2f} MB")
        log(f"   è¾“å‡ºå¤§å°: {output_size_mb:.2f} MB")
        log(f"   åˆæˆæ–¹å¼: Stream Copy (æ— æŸ)")

        return output_file

    except subprocess.TimeoutExpired:
        log(f"âŒ è§†é¢‘åˆæˆè¶…æ—¶ï¼ˆ>60ç§’ï¼‰", "ERROR")
        raise
    except Exception as e:
        log(f"âŒ è§†é¢‘åˆæˆå¤±è´¥ï¼š{e}", "ERROR")
        raise

def batch_merge_all():
    """æ‰¹é‡åˆæˆæ‰€æœ‰outputå­ç›®å½•ä¸‹çš„è§†é¢‘"""
    import subprocess
    import imageio_ffmpeg

    print("=" * 60)
    print("ğŸš€ æ‰¹é‡è§†é¢‘åˆæˆæ¨¡å¼")
    print("=" * 60)
    print(f"ğŸ“‚ æ‰«æç›®å½•: {OUTPUT_BASE.absolute()}\n")

    # è·å–ffmpeg
    try:
        ffmpeg_bin = imageio_ffmpeg.get_ffmpeg_exe()
    except Exception as e:
        print(f"âŒ æ— æ³•è·å–ffmpeg: {e}")
        return 1

    # æŸ¥æ‰¾æ‰€æœ‰aka-*å­ç›®å½•
    subdirs = sorted([d for d in OUTPUT_BASE.glob("aka-*") if d.is_dir()])

    if not subdirs:
        print("âŒ æœªæ‰¾åˆ°ä»»ä½•aka-*å­ç›®å½•")
        return 1

    print(f"âœ“ æ‰¾åˆ° {len(subdirs)} ä¸ªå­ç›®å½•\n")

    # ç»Ÿè®¡
    success_count = 0
    skip_count = 0
    fail_count = 0

    # é€ä¸ªå¤„ç†
    for work_dir in subdirs:
        print(f"\n{'='*60}")
        print(f"ğŸ“‚ å¤„ç†ç›®å½•: {work_dir.name}")
        print(f"{'='*60}")

        # æ£€æŸ¥æ˜¯å¦å·²æœ‰åˆæˆè§†é¢‘
        output_file = work_dir / "90_final.mp4"
        if output_file.exists():
            size_mb = output_file.stat().st_size / 1024 / 1024
            print(f"   âœ“ å·²å­˜åœ¨åˆæˆè§†é¢‘: {output_file.name} ({size_mb:.2f} MB)")
            print(f"   â­ï¸  è·³è¿‡æ­¤ç›®å½•")
            skip_count += 1
            continue

        # æŸ¥æ‰¾æ‰€æœ‰ç¼–å·çš„é•œå¤´è§†é¢‘æ–‡ä»¶ï¼ˆ50-69ç³»åˆ—ï¼‰
        video_files = sorted(work_dir.glob("[0-9][0-9]_shot_[0-9][0-9].mp4"))

        if not video_files:
            print(f"   âš ï¸  æœªæ‰¾åˆ°åˆ†é•œå¤´æ–‡ä»¶ï¼Œè·³è¿‡")
            skip_count += 1
            continue

        print(f"   ğŸ“¹ æ‰¾åˆ° {len(video_files)} ä¸ªåˆ†é•œå¤´:")
        total_input_size = 0
        for vf in video_files:
            size_mb = vf.stat().st_size / 1024 / 1024
            total_input_size += size_mb
            print(f"      - {vf.name}: {size_mb:.2f} MB")

        # åˆ›å»ºæ–‡ä»¶åˆ—è¡¨
        filelist_path = work_dir / "85_filelist.txt"
        with open(filelist_path, "w") as f:
            for vf in video_files:
                f.write(f"file '{vf.name}'\n")

        # æ‰§è¡ŒFFmpegåˆæˆ
        print(f"   ğŸ”— å¼€å§‹åˆæˆ...")

        cmd = [
            ffmpeg_bin,
            "-f", "concat",
            "-safe", "0",
            "-i", "85_filelist.txt",
            "-c", "copy",
            "-y",
            "90_final.mp4"
        ]

        try:
            start_time = datetime.now()

            result = subprocess.run(
                cmd,
                cwd=str(work_dir),
                capture_output=True,
                text=True,
                timeout=60
            )

            # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
            if filelist_path.exists():
                filelist_path.unlink()

            if result.returncode != 0:
                print(f"   âŒ åˆæˆå¤±è´¥: {result.stderr[:200]}")
                fail_count += 1
                continue

            if not output_file.exists():
                print(f"   âŒ åˆæˆå¤±è´¥: è¾“å‡ºæ–‡ä»¶æœªç”Ÿæˆ")
                fail_count += 1
                continue

            # ç»Ÿè®¡ä¿¡æ¯
            elapsed = (datetime.now() - start_time).total_seconds()
            output_size_mb = output_file.stat().st_size / 1024 / 1024

            print(f"   âœ… åˆæˆæˆåŠŸï¼")
            print(f"      è¾“å‡º: {output_file.name}")
            print(f"      è¾“å…¥å¤§å°: {total_input_size:.2f} MB")
            print(f"      è¾“å‡ºå¤§å°: {output_size_mb:.2f} MB")
            print(f"      è€—æ—¶: {elapsed:.1f}ç§’")

            success_count += 1

        except subprocess.TimeoutExpired:
            print(f"   âŒ åˆæˆè¶…æ—¶ï¼ˆ>60ç§’ï¼‰")
            fail_count += 1
        except Exception as e:
            print(f"   âŒ åˆæˆå¤±è´¥: {e}")
            fail_count += 1

    # è¾“å‡ºæ€»ç»“
    print(f"\n{'='*60}")
    print(f"ğŸ“Š æ‰¹é‡åˆæˆå®Œæˆ")
    print(f"{'='*60}")
    print(f"   æ€»è®¡: {len(subdirs)} ä¸ªç›®å½•")
    print(f"   âœ… æˆåŠŸåˆæˆ: {success_count} ä¸ª")
    print(f"   â­ï¸  å·²å­˜åœ¨è·³è¿‡: {skip_count} ä¸ª")
    print(f"   âŒ å¤±è´¥: {fail_count} ä¸ª")

    # åˆ—å‡ºæ‰€æœ‰åˆæˆè§†é¢‘
    all_finals = sorted(OUTPUT_BASE.glob("aka-*/90_final.mp4"))
    if all_finals:
        print(f"\nğŸ“¹ æ‰€æœ‰åˆæˆè§†é¢‘:")
        for final in all_finals:
            size_mb = final.stat().st_size / 1024 / 1024
            print(f"   - {final.parent.name}/90_final.mp4 ({size_mb:.2f} MB)")

    return 0 if fail_count == 0 else 1

def main():
    """ä¸»æµç¨‹"""
    global MAX_CONCURRENT_WORKERS, WORK_DIR, LOG_FILE, RUN_TIMESTAMP
    start_time = time.time()

    # è§£æå‘½ä»¤è¡Œå‚æ•°
    parser = argparse.ArgumentParser(description='AIè§†é¢‘ç”Ÿæˆç³»ç»Ÿ - æ™ºèƒ½æ–­ç‚¹ç»§ç»­')
    parser.add_argument('--resume', type=str, metavar='DIR_NAME',
                       help='æ‰‹åŠ¨æŒ‡å®šæ¢å¤çš„å·¥ä½œç›®å½• (ä¾‹å¦‚: aka-12221430)')
    parser.add_argument('--no-auto-resume', action='store_true',
                       help='ç¦ç”¨è‡ªåŠ¨æ–­ç‚¹æ£€æµ‹ï¼Œå¼ºåˆ¶åˆ›å»ºæ–°ä»»åŠ¡')
    args = parser.parse_args()

    # åˆå§‹åŒ–å·¥ä½œç›®å½•
    OUTPUT_BASE.mkdir(exist_ok=True)

    # ä¼˜å…ˆçº§ï¼šæ‰‹åŠ¨æŒ‡å®š > è‡ªåŠ¨æ£€æµ‹ > æ–°å»º
    if args.resume:
        # ç”¨æˆ·æ˜ç¡®æŒ‡å®šæ¢å¤ç›®å½•
        WORK_DIR = OUTPUT_BASE / args.resume
        if not WORK_DIR.exists():
            print(f"âŒ é”™è¯¯: æŒ‡å®šçš„ç›®å½•ä¸å­˜åœ¨: {WORK_DIR}")
            print(f"   è¯·æ£€æŸ¥ output/ ç›®å½•ä¸‹æ˜¯å¦æœ‰ {args.resume}")
            return 1
        RUN_TIMESTAMP = args.resume.replace('aka-', '')
        print(f"ğŸ”„ æ‰‹åŠ¨æ¢å¤: {WORK_DIR.name}\n")
    elif not args.no_auto_resume:
        # è‡ªåŠ¨æ£€æµ‹æ˜¯å¦éœ€è¦æ¢å¤
        resume_dir = auto_resume_check()
        if resume_dir:
            WORK_DIR = resume_dir
            RUN_TIMESTAMP = resume_dir.name.replace('aka-', '')
            print(f"ğŸ”„ è‡ªåŠ¨æ¢å¤: {WORK_DIR.name}\n")
        else:
            # å¼€å§‹æ–°ä»»åŠ¡
            RUN_TIMESTAMP = datetime.now().strftime("%m%d%H%M")
            WORK_DIR = OUTPUT_BASE / f'aka-{RUN_TIMESTAMP}'
            WORK_DIR.mkdir(exist_ok=True)
            print(f"ğŸ†• æ–°å»ºä»»åŠ¡: {WORK_DIR.name}\n")
    else:
        # ç”¨æˆ·ç¦ç”¨è‡ªåŠ¨æ£€æµ‹ï¼Œå¼ºåˆ¶æ–°å»º
        RUN_TIMESTAMP = datetime.now().strftime("%m%d%H%M")
        WORK_DIR = OUTPUT_BASE / f'aka-{RUN_TIMESTAMP}'
        WORK_DIR.mkdir(exist_ok=True)
        print(f"ğŸ†• æ–°å»ºä»»åŠ¡: {WORK_DIR.name} (å·²ç¦ç”¨è‡ªåŠ¨æ£€æµ‹)\n")

    LOG_FILE = WORK_DIR / '01_log.txt'

    # éªŒè¯é…ç½®
    try:
        validate_config()
    except ValueError as e:
        print(str(e))
        print("\nè¯·æ£€æŸ¥ .env æ–‡ä»¶å¹¶ç¡®ä¿æ‰€æœ‰å¿…éœ€çš„é…ç½®æ­£ç¡®")
        return 1

    # æ˜¾ç¤ºåˆå§‹ä½™é¢
    print()
    print("=" * 60)
    print("ğŸ’° è´¦æˆ·ä½™é¢æŸ¥è¯¢")
    print("=" * 60)
    initial_balance = get_wavespeed_balance()
    if initial_balance is not None:
        print(f"{Colors.GREEN}âœ… WavespeedAI è´¦æˆ·ä½™é¢: ${initial_balance:.4f}{Colors.RESET}")
        if initial_balance < 1.0:
            print(f"{Colors.YELLOW}âš ï¸  ä½™é¢è¾ƒä½ï¼Œå»ºè®®å……å€¼ä»¥ç¡®ä¿ä»»åŠ¡é¡ºåˆ©å®Œæˆ{Colors.RESET}")
    else:
        print(f"{Colors.YELLOW}âš ï¸  æ— æ³•æŸ¥è¯¢ä½™é¢ï¼Œå°†ç»§ç»­æ‰§è¡Œï¼ˆå¯èƒ½æ˜¯ç½‘ç»œé—®é¢˜ï¼‰{Colors.RESET}")
    print("=" * 60)
    print()

    # å°è¯•ä»TOMLé…ç½®æ–‡ä»¶åŠ è½½é…ç½®
    config_result = load_config_from_toml('config.toml')

    if config_result:
        # ä»TOMLæˆåŠŸåŠ è½½
        user_config, concurrent_workers = config_result
        MAX_CONCURRENT_WORKERS = concurrent_workers

        # å¦‚æœTOMLä¸­æœ‰å­—å¹•é…ç½®ï¼Œè¦†ç›–YAMLä¸­çš„å­—å¹•é…ç½®
        if 'subtitle' in user_config:
            if 'subtitle' not in CONFIG:
                CONFIG['subtitle'] = {}
            CONFIG['subtitle'].update(user_config['subtitle'])
    else:
        # å›é€€åˆ°äº¤äº’å¼è¾“å…¥
        print(f"\n{Colors.YELLOW}âš ï¸  æœªæ‰¾åˆ°æˆ–æ— æ³•åŠ è½½ config.tomlï¼Œåˆ‡æ¢åˆ°äº¤äº’å¼é…ç½®æ¨¡å¼{Colors.RESET}\n")
        print(f"{Colors.GRAY}æç¤ºï¼šåˆ›å»º config.toml æ–‡ä»¶å¯è·³è¿‡äº¤äº’å¼è¾“å…¥{Colors.RESET}")
        print(f"{Colors.GRAY}å‚è€ƒç¤ºä¾‹ï¼šconfig.example.toml{Colors.RESET}\n")

        # ç”¨æˆ·äº¤äº’ï¼šè·å–é…ç½®
        user_config = interactive_setup()

        # è¯¢é—®å¹¶å‘çº¿ç¨‹æ•°
        MAX_CONCURRENT_WORKERS = ask_concurrent_workers()

    # æ¸…ç©ºæ—§æ—¥å¿—
    if LOG_FILE.exists():
        LOG_FILE.unlink()

    log("=" * 60)
    log("ğŸ¬ AIè§†é¢‘ç”Ÿæˆç³»ç»Ÿ v2.0")
    log("=" * 60)
    log(f"å¼€å§‹æ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    log(f"è¿è¡ŒID: aka-{RUN_TIMESTAMP}")
    log(f"ä¸»é¢˜: {user_config['topic']}")
    log(f"é£æ ¼: {STYLE_TEMPLATES[user_config['style']]['name']}")
    log(f"é•œå¤´æ•°: {user_config['shot_count']}ä¸ª")
    log(f"å•é•œå¤´æ—¶é•¿: {user_config['shot_duration']}ç§’")
    log(f"å¹¶å‘çº¿ç¨‹æ•°: {MAX_CONCURRENT_WORKERS}")
    log(f"è¾“å‡ºç›®å½•: {WORK_DIR.absolute()}")
    log(f"æ—¥å¿—æ–‡ä»¶: {LOG_FILE.absolute()}")
    log("=" * 60)

    try:
        # åˆå§‹åŒ–éŸ³è§†é¢‘æœåŠ¡
        audio_config = CONFIG.get('audio', {})
        subtitle_config = CONFIG.get('subtitle', {})

        voice_service = VoiceService(provider=audio_config.get('voice_provider', 'edge'))
        subtitle_service = SubtitleService(provider=subtitle_config.get('subtitle_provider', 'submaker'))
        video_composer = VideoComposer(temp_dir=str(WORK_DIR))

        log("âœ“ éŸ³è§†é¢‘æœåŠ¡åˆå§‹åŒ–å®Œæˆ")

        # é˜¶æ®µ0: ä¸€è‡´æ€§èµ„äº§ç”Ÿæˆï¼ˆå¦‚æœå¯ç”¨ï¼‰
        if user_config.get('character', {}).get('enabled'):
            character_image_path = user_config['character'].get('character_image')

            # æ£€æŸ¥æ˜¯å¦æœ‰å¯ç”¨çš„å‚è€ƒå›¾
            if character_image_path:
                log("")
                log("="*60)
                log("ğŸ‘¤ ä½¿ç”¨ä¸»è§’å‚è€ƒå›¾")
                log("="*60)
                log(f"   å‚è€ƒå›¾è·¯å¾„: {character_image_path}")

                # æ£€æŸ¥æ˜¯ URL è¿˜æ˜¯æœ¬åœ°æ–‡ä»¶
                if character_image_path.startswith(('http://', 'https://')):
                    # URL å›¾ç‰‡ï¼Œç›´æ¥ä½¿ç”¨
                    log(f"   âœ“ ä½¿ç”¨åœ¨çº¿å›¾ç‰‡ï¼ˆURLï¼‰")
                    character_ref_image_path = character_image_path
                else:
                    # æœ¬åœ°æ–‡ä»¶ï¼Œæ£€æŸ¥æ˜¯å¦å­˜åœ¨å¹¶å¤åˆ¶åˆ°å·¥ä½œç›®å½•
                    char_img_file = Path(character_image_path)
                    if not char_img_file.exists():
                        log(f"âŒ ä¸»è§’å‚è€ƒå›¾ä¸å­˜åœ¨: {character_image_path}", "ERROR")
                        raise FileNotFoundError(f"ä¸»è§’å‚è€ƒå›¾æ–‡ä»¶ä¸å­˜åœ¨: {character_image_path}")

                    # å¤åˆ¶å‚è€ƒå›¾åˆ°å·¥ä½œç›®å½•ï¼ˆä¿ç•™åŸå§‹æ‰©å±•åï¼‰
                    import shutil
                    char_img_ext = char_img_file.suffix
                    work_char_img = WORK_DIR / f'character_reference{char_img_ext}'
                    shutil.copy(char_img_file, work_char_img)
                    log(f"   âœ“ å‚è€ƒå›¾å·²æ‹·è´åˆ°é¡¹ç›®ç›®å½•: {work_char_img.name}")
                    character_ref_image_path = str(work_char_img)

                # ä½¿ç”¨å‚è€ƒå›¾è·¯å¾„
                character_ref = {
                    'description_cn': user_config['character']['description'],
                    'prompt_en': user_config['character']['description'],
                    'image_url': character_ref_image_path
                }
                character_dna = extract_character_dna(character_ref)

                user_config['character']['reference'] = character_ref
                user_config['character']['dna'] = character_dna
                log("âœ“ ä¸»è§’ä¸€è‡´æ€§èµ„äº§å‡†å¤‡å®Œæˆï¼ˆä½¿ç”¨å‚è€ƒå›¾ï¼‰\n")
            else:
                # è‡ªåŠ¨ç”Ÿæˆä¸»è§’å‚è€ƒå›¾
                character_ref = generate_character_reference(
                    user_config['character']['description']
                )
                character_dna = extract_character_dna(character_ref)

                # æ›´æ–°config
                user_config['character']['reference'] = character_ref
                user_config['character']['dna'] = character_dna

                log("âœ“ ä¸»è§’ä¸€è‡´æ€§èµ„äº§å‡†å¤‡å®Œæˆï¼ˆå·²ç”Ÿæˆï¼‰\n")

        # å‡†å¤‡å“ç‰Œèµ„äº§
        brand_assets = prepare_brand_assets(user_config.get('brand', {}))

        # é˜¶æ®µ1: ç”Ÿæˆæ•…äº‹åŒ–é•œå¤´è„šæœ¬ï¼ˆæ”¯æŒæ–­ç‚¹ç»­ä¼ ï¼‰
        log("\nğŸ“‹ é˜¶æ®µ 1: ç”Ÿæˆæ•…äº‹åŒ–é•œå¤´è„šæœ¬")
        log("=" * 60)

        script_file = WORK_DIR / '22_shots_script.json'
        if script_file.exists():
            log("ğŸ“‚ æ£€æµ‹åˆ°å·²æœ‰åˆ†é•œè„šæœ¬æ–‡ä»¶ï¼Œè·³è¿‡æ•…äº‹ç”Ÿæˆé˜¶æ®µ")
            try:
                with open(script_file, 'r', encoding='utf-8') as f:
                    shots_data = json.load(f)
                shot_count = len(shots_data['shots'])
                log(f"   å·²åŠ è½½ {shot_count} ä¸ªé•œå¤´")
                log(f"âœ“ é˜¶æ®µ1å®Œæˆï¼ˆä»ç¼“å­˜åŠ è½½ï¼‰\n")
            except Exception as e:
                log(f"âš ï¸  åŠ è½½åˆ†é•œè„šæœ¬å¤±è´¥: {e}ï¼Œå°†é‡æ–°ç”Ÿæˆ", "WARN")
                shots_data = generate_shots_script(config=user_config)
                shot_count = user_config['shot_count']
                log(f"âœ“ é˜¶æ®µ1å®Œæˆ\n")
        else:
            shots_data = generate_shots_script(config=user_config)
            shot_count = user_config['shot_count']
            log(f"âœ“ é˜¶æ®µ1å®Œæˆ\n")

        # åŠ è½½æ£€æŸ¥ç‚¹
        checkpoint = load_checkpoint()
        completed_ids = set(checkpoint.get('completed_shots', []))

        if completed_ids:
            log(f"ğŸ“‚ æ£€æµ‹åˆ°æ£€æŸ¥ç‚¹æ–‡ä»¶")
            log(f"   å·²å®Œæˆé•œå¤´: {sorted(completed_ids)}")
            log(f"   å°†è·³è¿‡å·²å®Œæˆçš„é•œå¤´ï¼Œç»§ç»­æœªå®Œæˆéƒ¨åˆ†\n")

        # è¿‡æ»¤å‡ºå¾…å¤„ç†çš„é•œå¤´
        pending_shots = [shot for shot in shots_data['shots'] if shot['id'] not in completed_ids]

        if not pending_shots:
            log("âœ… æ‰€æœ‰é•œå¤´éƒ½å·²å®Œæˆï¼Œè·³åˆ°åˆæˆé˜¶æ®µ\n")
        else:
            log(f"ğŸ“‹ éœ€è¦å¤„ç† {len(pending_shots)}/{shot_count} ä¸ªé•œå¤´\n")

        # é˜¶æ®µ2: ç”Ÿæˆå›¾åƒå’Œè§†é¢‘
        resolution = user_config['resolution']

        if USE_DIRECT_T2V:
            log("ğŸ¬ é˜¶æ®µ 2: ç”Ÿæˆè§†é¢‘ï¼ˆç›´æ¥T2Vï¼‰")
            log("-" * 60)
            log(f"ä½¿ç”¨æ–¹æ¡ˆ2ï¼šé€Ÿåº¦ä¼˜å…ˆ - WAN 2.6 T2V")
            log(f"éœ€è¦ç”Ÿæˆ {shot_count} ä¸ªé•œå¤´")
            video_config = VIDEO_MODEL_CONFIG[CURRENT_VIDEO_MODEL]
            video_cost = get_video_cost(CURRENT_VIDEO_MODEL, resolution)
            log(f"é¢„è®¡æ¯ä¸ªé•œå¤´: {video_config['speed']}")
            log(f"å•é•œå¤´æˆæœ¬: ${video_cost:.2f} ({resolution})")
            log(f"æ€»æˆæœ¬: ${video_cost * shot_count:.2f}")
        else:
            log("ğŸ¬ é˜¶æ®µ 2: ç”Ÿæˆå›¾åƒå’Œè§†é¢‘ï¼ˆI2Vä¸¤æ­¥æµç¨‹ï¼‰")
            log("-" * 60)
            log(f"ä½¿ç”¨æ–¹æ¡ˆ1ï¼šæ€§ä»·æ¯”æ–¹æ¡ˆ")
            log(f"éœ€è¦ç”Ÿæˆ {shot_count} ä¸ªé•œå¤´")
            image_config = IMAGE_MODEL_CONFIG[CURRENT_IMAGE_MODEL]
            video_config = VIDEO_MODEL_CONFIG[CURRENT_VIDEO_MODEL]
            video_cost = get_video_cost(CURRENT_VIDEO_MODEL, resolution)

            # è®¡ç®—æ€»æˆæœ¬ï¼ˆåŒ…æ‹¬ä¸»è§’å‚è€ƒå›¾ï¼‰
            character_ref_cost = image_config['cost'] if user_config.get('character', {}).get('enabled') else 0
            total_cost = character_ref_cost + (image_config['cost'] + video_cost) * shot_count

            log(f"å›¾åƒæ¨¡å‹: {CURRENT_IMAGE_MODEL} (${image_config['cost']}/ä¸ª)")
            log(f"è§†é¢‘æ¨¡å‹: {CURRENT_VIDEO_MODEL} (${video_cost:.2f}/ä¸ª @ {resolution})")
            log(f"å•é•œå¤´æˆæœ¬: ${image_config['cost'] + video_cost:.2f}")
            if character_ref_cost > 0:
                log(f"ä¸»è§’å‚è€ƒå›¾: ${character_ref_cost:.2f}")
            log(f"é¢„è®¡æ€»æˆæœ¬: ${total_cost:.2f}")

        # è®°å½•æˆåŠŸå’Œå¤±è´¥çš„é•œå¤´
        successful_shots = list(completed_ids)  # å·²å®Œæˆçš„é•œå¤´
        failed_shots = checkpoint.get('failed_shots', [])

        if USE_DIRECT_T2V:
            # æ–¹æ¡ˆ2: ç›´æ¥T2V - å¹¶å‘å¤„ç†
            shots_with_images = [(shot, None) for shot in pending_shots]

            if shots_with_images:
                # å¹¶å‘ç”Ÿæˆæ‰€æœ‰è§†é¢‘ï¼ˆT2Vï¼Œæ— éœ€å›¾åƒï¼‰
                video_results, video_failures = generate_videos_parallel(shots_with_images, shot_count, user_config['resolution'])

                # æ›´æ–°æˆåŠŸåˆ—è¡¨
                for shot_id in video_results.keys():
                    successful_shots.append(shot_id)

                # æ›´æ–°å¤±è´¥åˆ—è¡¨
                failed_shots.extend(video_failures)

                # ä¿å­˜æ£€æŸ¥ç‚¹
                checkpoint['completed_shots'] = successful_shots
                checkpoint['failed_shots'] = failed_shots
                save_checkpoint(checkpoint)
                log(f"   ğŸ’¾ æ£€æŸ¥ç‚¹å·²ä¿å­˜")

        else:
            # æ–¹æ¡ˆ1: I2Vä¸¤æ­¥æ¨¡å¼ - å›¾åƒå¹¶å‘ï¼Œè§†é¢‘å¹¶å‘
            log("ğŸ¨ é˜¶æ®µ 3a: å¹¶å‘ç”Ÿæˆå›¾åƒ")
            log("-" * 60)

            # æ£€æŸ¥å·²å­˜åœ¨çš„å›¾åƒæ–‡ä»¶
            image_urls = {}
            shots_need_images = []

            for shot in pending_shots:
                image_num = 30 + (shot['id'] - 1)
                image_file = WORK_DIR / f"{image_num:02d}_shot_{shot['id']:02d}_image.png"
                if image_file.exists():
                    # å›¾åƒå·²å­˜åœ¨ï¼Œä½¿ç”¨æœ¬åœ°è·¯å¾„
                    image_urls[shot['id']] = str(image_file)
                    log(f"âœ“ é•œå¤´ {shot['id']} å›¾åƒå·²å­˜åœ¨ï¼Œè·³è¿‡ç”Ÿæˆ")
                else:
                    shots_need_images.append(shot)

            # å¹¶å‘ç”Ÿæˆç¼ºå¤±çš„å›¾åƒ
            if shots_need_images:
                log(f"ğŸ“‹ éœ€è¦ç”Ÿæˆ {len(shots_need_images)}/{len(pending_shots)} ä¸ªå›¾åƒ")

                # è·å–ä¸»è§’å‚è€ƒå›¾è·¯å¾„ï¼ˆå¦‚æœå¯ç”¨ï¼‰
                character_image_path = None
                if user_config.get('character', {}).get('enabled'):
                    character_ref = user_config.get('character', {}).get('reference', {})
                    character_image_path = character_ref.get('image_url')

                new_image_urls = generate_images_parallel(shots_need_images, shot_count, character_image_path)
                image_urls.update(new_image_urls)
            else:
                log("âœ“ æ‰€æœ‰å›¾åƒéƒ½å·²å­˜åœ¨ï¼Œè·³è¿‡å›¾åƒç”Ÿæˆ")

            log("\nğŸ¬ é˜¶æ®µ 3b: å¹¶å‘ç”Ÿæˆè§†é¢‘")
            log("-" * 60)

            # å‡†å¤‡å¹¶å‘ç”Ÿæˆæ•°æ®ï¼ˆåªå¤„ç†å›¾åƒç”ŸæˆæˆåŠŸçš„é•œå¤´ï¼‰
            shots_with_images = [
                (shot, image_urls.get(shot['id']))
                for shot in pending_shots
                if shot['id'] in image_urls
            ]

            if not shots_with_images:
                log("âš ï¸  æ²¡æœ‰å¯ç”¨çš„å›¾åƒï¼Œè·³è¿‡è§†é¢‘ç”Ÿæˆ", "WARN")
            else:
                # å¹¶å‘ç”Ÿæˆæ‰€æœ‰è§†é¢‘
                video_results, video_failures = generate_videos_parallel(shots_with_images, shot_count, user_config['resolution'])

                # æ›´æ–°æˆåŠŸåˆ—è¡¨
                for shot_id in video_results.keys():
                    successful_shots.append(shot_id)

                # æ›´æ–°å¤±è´¥åˆ—è¡¨
                failed_shots.extend(video_failures)

                # ä¿å­˜æ£€æŸ¥ç‚¹
                checkpoint['completed_shots'] = successful_shots
                checkpoint['failed_shots'] = failed_shots
                save_checkpoint(checkpoint)
                log(f"   ğŸ’¾ æ£€æŸ¥ç‚¹å·²ä¿å­˜")

        # æŠ¥å‘Šç»“æœ
        log(f"\nğŸ“Š ç”Ÿæˆç»“æœæ±‡æ€»:")
        log(f"   âœ… æˆåŠŸ: {len(successful_shots)}/{shot_count}")
        log(f"   âŒ å¤±è´¥: {len(failed_shots)}/{shot_count}")

        if failed_shots:
            log(f"\nâš ï¸  å¤±è´¥çš„é•œå¤´:")
            for shot_id, error in failed_shots:
                log(f"   - é•œå¤´ {shot_id}: {error[:100]}...")

        if len(successful_shots) == 0:
            raise RuntimeError("æ‰€æœ‰é•œå¤´éƒ½ç”Ÿæˆå¤±è´¥ï¼Œæ— æ³•ç»§ç»­")

        log(f"âœ“ é˜¶æ®µ2å®Œæˆ\n")

        # é˜¶æ®µ2.5: æ·»åŠ å“ç‰Œå…ƒç´ ï¼ˆå¦‚æœå¯ç”¨ï¼‰
        if brand_assets.get('enabled'):
            log("ğŸ¢ é˜¶æ®µ 2.5: æ·»åŠ å“ç‰Œå…ƒç´ ")
            log("-" * 60)

            # ä¸ºæ‰€æœ‰å·²ç”Ÿæˆçš„é•œå¤´æ·»åŠ å“ç‰Œ
            for shot_id in range(1, shot_count + 1):
                video_num = 50 + (shot_id - 1)
                video_path = WORK_DIR / f'{video_num:02d}_shot_{shot_id:02d}.mp4'

                if video_path.exists():
                    log(f"   ğŸ¨ ä¸ºé•œå¤´ {shot_id}/{shot_count} æ·»åŠ å“ç‰Œlogo...")
                    add_brand_overlay(str(video_path), brand_assets)
                else:
                    log(f"   â­ï¸  é•œå¤´ {shot_id} ä¸å­˜åœ¨ï¼Œè·³è¿‡")

            log(f"âœ“ é˜¶æ®µ3.5å®Œæˆ\n")

        # ç»Ÿè®¡è§†é¢‘æ—¶é•¿ï¼ˆç”¨äºå…¨ç‰‡æ—ç™½ï¼‰
        log("â±ï¸  ç»Ÿè®¡è§†é¢‘æ—¶é•¿å¹¶å‡†å¤‡å…¨ç‰‡æ‹¼æ¥...")
        video_durations = {}
        total_video_duration = 0.0
        shot_durations_list = []
        for i in range(1, shot_count + 1):
            video_num = 50 + (i - 1)
            vf = WORK_DIR / f"{video_num:02d}_shot_{i:02d}.mp4"
            if vf.exists():
                dur = get_video_duration_seconds(vf)
                video_durations[i] = dur
                shot_durations_list.append(dur)
                total_video_duration += dur
                log(f"   é•œå¤´ {i}: {dur:.2f}s")
            else:
                log(f"   âš ï¸ é•œå¤´ {i} è§†é¢‘ç¼ºå¤±ï¼Œè·³è¿‡æ—¶é•¿ç»Ÿè®¡", "WARN")
                shot_durations_list.append(0.0)

        log(f"â±ï¸  å…¨ç‰‡æ—¶é•¿ï¼ˆé™éŸ³ç‰ˆï¼‰: {total_video_duration:.2f}s\n")

        # é˜¶æ®µ3: æ•´æ¡æ—ç™½ä¸å­—å¹•ï¼ˆå•æ¡éŸ³è½¨ï¼Œä¿æŒåŒæ­¥ï¼‰
        log("ğŸ¤ é˜¶æ®µ 3: æ•´æ¡æ—ç™½ä¸å­—å¹•")
        log("=" * 60)

        global_audio = WORK_DIR / "70_global_narration.mp3"
        global_subtitle = WORK_DIR / "71_global_subtitle.srt"

        if global_audio.exists() and global_subtitle.exists():
            log("âœ“ æ£€æµ‹åˆ°å…¨ç‰‡æ—ç™½ä¸å­—å¹•ï¼Œè·³è¿‡ç”Ÿæˆ")
        else:
            sentences = generate_global_narration(shots_data, video_durations)

            full_text = "\n".join(sentences)
            log("   ğŸ™ï¸  è°ƒç”¨TTSç”Ÿæˆæ•´ç‰‡æ—ç™½éŸ³é¢‘...")
            sub_maker, audio_duration = voice_service.generate_audio(
                text=full_text,
                output_file=str(global_audio),
                voice_name=audio_config.get('voice_name', 'zh-CN-XiaoxiaoNeural')
            )

            if not sub_maker:
                log("âŒ æ•´ç‰‡æ—ç™½ç”Ÿæˆå¤±è´¥ï¼Œç»ˆæ­¢", "ERROR")
                return 1

            raw_srt = WORK_DIR / "73_global_subtitle_raw.srt"
            write_srt_from_submaker(sub_maker, raw_srt)

            # ç›®æ ‡æ—¶é•¿ï¼šå…¨ç‰‡æ—¶é•¿å‡å»2ç§’ç¼“å†²ï¼ˆç²¾ç¡®æ§åˆ¶ï¼‰
            target_total = total_video_duration - 2.0
            if target_total <= 0:
                target_total = 0.5

            scaled = False
            speed_factor = 1.0
            if audio_duration > target_total:
                speed_factor = min(1.8, audio_duration / target_total)
                adjusted = WORK_DIR / "72_global_narration_speed.mp3"
                if speedup_audio_file(global_audio, adjusted, speed_factor):
                    global_audio.unlink(missing_ok=True)
                    adjusted.rename(global_audio)
                    audio_duration = audio_duration / speed_factor
                    scaled = True
                    log(f"   âš ï¸  æ—ç™½è¶…æ—¶ï¼Œå·²åŠ é€Ÿ {speed_factor:.2f}x â†’ {audio_duration:.2f}s")
                else:
                    log("   âš ï¸  åŠ é€Ÿå¤±è´¥ï¼Œç»§ç»­ä½¿ç”¨åŸå§‹éŸ³é¢‘", "WARN")

            if scaled:
                rescale_srt_timestamps(str(raw_srt), str(global_subtitle), 1 / speed_factor)
            else:
                raw_srt.rename(global_subtitle)
            raw_srt.unlink(missing_ok=True)

            log(f"âœ“ é˜¶æ®µ3å®Œæˆï¼ˆæ—ç™½ {audio_duration:.2f}sï¼‰\n")

        # é˜¶æ®µ4: æ•´ç‰‡éŸ³è§†é¢‘åˆæˆ
        log("ğŸï¸  é˜¶æ®µ 4: æ•´ç‰‡éŸ³è§†é¢‘åˆæˆ")
        log("-" * 60)

        # 4a. æ‹¼æ¥æ‰€æœ‰é•œå¤´ï¼ˆé™éŸ³/å·²åŠ å“ç‰Œï¼‰
        log("ğŸï¸  æ­¥éª¤4a: æ‹¼æ¥æ‰€æœ‰é•œå¤´...")
        video_files = []
        for i in range(1, shot_count + 1):
            video_num = 50 + (i - 1)
            shot_path = WORK_DIR / f"{video_num:02d}_shot_{i:02d}.mp4"
            if shot_path.exists():
                video_files.append(str(shot_path))
            else:
                log(f"  âš ï¸  é•œå¤´ {i} è§†é¢‘ç¼ºå¤±ï¼Œè·³è¿‡", "WARN")

        temp_output = WORK_DIR / "80_temp_concat.mp4"
        if video_files:
            log(f"  ğŸ¬ æ‹¼æ¥ {len(video_files)} ä¸ªé•œå¤´...")
            success = video_composer.concatenate_videos(video_files, str(temp_output))
        else:
            success = False

        if success:
            # 4b. å åŠ æ•´ç‰‡æ—ç™½
            temp_with_audio = WORK_DIR / "81_temp_with_audio.mp4"
            global_audio = WORK_DIR / "70_global_narration.mp3"
            if global_audio.exists():
                log("ğŸ™ï¸  æ­¥éª¤4b: å åŠ æ•´ç‰‡æ—ç™½éŸ³é¢‘...")
                success_audio = video_composer.add_audio_to_video(
                    str(temp_output),
                    str(global_audio),
                    str(temp_with_audio)
                )
                if not success_audio:
                    log("âŒ  æ•´ç‰‡æ—ç™½æ·»åŠ å¤±è´¥", "ERROR")
                    temp_with_audio = temp_output
            else:
                log("âš ï¸  æœªæ‰¾åˆ°æ•´ç‰‡æ—ç™½éŸ³é¢‘ï¼Œç›´æ¥ä½¿ç”¨é™éŸ³æ‹¼æ¥è§†é¢‘", "WARN")
                temp_with_audio = temp_output

            # 4c. æ·»åŠ æ•´ç‰‡å­—å¹•
            final_no_bgm = WORK_DIR / "82_temp_with_subtitle.mp4"
            global_subtitle = WORK_DIR / "71_global_subtitle.srt"
            if global_subtitle.exists():
                log("ğŸ“ æ­¥éª¤4c: æ·»åŠ æ•´ç‰‡å­—å¹•...")
                font_config = subtitle_config.get('font_name', '')
                if font_config and not font_config.startswith('/') and not font_config.endswith('.ttc') and not font_config.endswith('.ttf'):
                    font_path = VideoComposer.get_system_font()
                else:
                    font_path = font_config if font_config else VideoComposer.get_system_font()

                success_sub = video_composer.add_subtitles_to_video(
                    str(temp_with_audio),
                    str(global_subtitle),
                    str(final_no_bgm),
                    style_config={
                        'font': font_path,
                        'fontsize': subtitle_config.get('font_size', 48),
                        'color': subtitle_config.get('font_color', 'white'),
                        'stroke_color': subtitle_config.get('outline_color', 'black'),
                        'stroke_width': subtitle_config.get('outline_width', 2),
                    }
                )
                if not success_sub:
                    log("âš ï¸  å­—å¹•æ·»åŠ å¤±è´¥ï¼Œä½¿ç”¨æ— å­—å¹•ç‰ˆæœ¬", "WARN")
                    final_no_bgm = temp_with_audio
            else:
                log("âš ï¸  æœªæ‰¾åˆ°æ•´ç‰‡å­—å¹•ï¼Œè·³è¿‡å­—å¹•æ·»åŠ ", "WARN")
                final_no_bgm = temp_with_audio

            # 4d. æ·»åŠ èƒŒæ™¯éŸ³ä¹ï¼ˆå¯é€‰ï¼‰
            final_video_path = WORK_DIR / "90_final.mp4"
            if audio_config.get('enable_background_music', False):
                log("\nğŸµ æ­¥éª¤4d: æ·»åŠ èƒŒæ™¯éŸ³ä¹...")
                music_service = MusicService(
                    music_dir=audio_config.get('music_dir', './resource/songs')
                )
                music_added = False
                max_music_attempts = 3
                available_music = music_service.get_available_music(validate=True)

                if not available_music:
                    log("  â„¹ï¸  æœªæ‰¾åˆ°æœ‰æ•ˆçš„èƒŒæ™¯éŸ³ä¹æ–‡ä»¶ï¼Œè·³è¿‡")
                    final_no_bgm.rename(final_video_path)
                else:
                    # æ™ºèƒ½éŸ³ä¹åŒ¹é…ï¼ˆæ–°åŠŸèƒ½ï¼‰
                    use_intelligent = audio_config.get('use_intelligent_music_matching', False)

                    if use_intelligent:
                        log("  ğŸ§  ä½¿ç”¨æ™ºèƒ½éŸ³ä¹åŒ¹é…ï¼ˆåŸºäºæ—ç™½éŸ³é¢‘åˆ†æï¼‰...")

                        # æ”¶é›†æ‰€æœ‰æ—ç™½éŸ³é¢‘æ–‡ä»¶
                        narration_audio_files = []
                        for i in range(1, shot_count + 1):
                            audio_num = 30 + (i - 1)
                            audio_path = WORK_DIR / f"{audio_num:02d}_narration_{i:02d}.mp3"
                            if audio_path.exists():
                                narration_audio_files.append(audio_path)

                        if narration_audio_files:
                            music_file_path = music_service.select_music_intelligent(
                                narration_audio_files=narration_audio_files,
                                visual_style=user_config.get('style')
                            )
                        else:
                            log("  âš ï¸  æœªæ‰¾åˆ°æ—ç™½éŸ³é¢‘æ–‡ä»¶ï¼Œé™çº§åˆ°å…³é”®è¯åŒ¹é…", "WARN")
                            use_intelligent = False

                    if not use_intelligent:
                        log("  ğŸ” ä½¿ç”¨å…³é”®è¯åŒ¹é…...")
                        music_file_path = music_service.select_music(
                            style=user_config.get('style'),
                            prefer_style=audio_config.get('prefer_style_match', True)
                        )

                    # å°è¯•æ·»åŠ éŸ³ä¹ï¼ˆé‡è¯•æœºåˆ¶ï¼‰
                    for attempt in range(max_music_attempts):
                        if attempt > 0:
                            # ç¬¬ä¸€æ¬¡å°è¯•å¤±è´¥åï¼Œé‡æ–°é€‰æ‹©éŸ³ä¹
                            log(f"  ğŸ”„ å°è¯•é€‰æ‹©å…¶ä»–éŸ³ä¹ ({attempt + 1}/{max_music_attempts})...")
                            music_file_path = music_service.select_music(
                                style=user_config.get('style'),
                                prefer_style=audio_config.get('prefer_style_match', True)
                            )

                        if not music_file_path:
                            log("  â„¹ï¸  æœªæ‰¾åˆ°èƒŒæ™¯éŸ³ä¹ï¼Œè·³è¿‡")
                            final_no_bgm.rename(final_video_path)
                            break

                        music_file = str(music_file_path)
                        final_output = final_video_path

                        log(f"  ğŸµ å°è¯•æ·»åŠ éŸ³ä¹: {music_file_path.name}")
                        success = video_composer.add_background_music(
                            str(final_no_bgm),
                            music_file,
                            str(final_output),
                            voice_volume=audio_config.get('voice_volume', 1.0),
                            music_volume=audio_config.get('music_volume', 0.25)
                        )

                        if success:
                            log("  âœ… èƒŒæ™¯éŸ³ä¹æ·»åŠ æˆåŠŸ")
                            music_added = True
                            break
                        else:
                            log(f"  âš ï¸  éŸ³ä¹æ·»åŠ å¤±è´¥: {music_file_path.name}", "WARN")
                            if attempt < max_music_attempts - 1:
                                log(f"  ğŸ”„ å°è¯•é€‰æ‹©å…¶ä»–éŸ³ä¹ ({attempt + 2}/{max_music_attempts})...")
                                if music_file_path in available_music:
                                    available_music.remove(music_file_path)
                            else:
                                log("  âš ï¸  è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œä½¿ç”¨æ— èƒŒæ™¯éŸ³ä¹ç‰ˆæœ¬", "WARN")
                                final_no_bgm.rename(final_video_path)
            else:
                # ä¸æ·»åŠ èƒŒæ™¯éŸ³ä¹ï¼Œç›´æ¥é‡å‘½å
                final_no_bgm.rename(final_video_path)
                log("  â„¹ï¸  èƒŒæ™¯éŸ³ä¹åŠŸèƒ½æœªå¯ç”¨")

            # 4e. æ·»åŠ LogoåŠ¨ç”»ï¼ˆå¯é€‰ï¼Œç‰‡å°¾æ·¡å…¥ï¼‰
            logo_config = CONFIG.get('logo', {})
            if logo_config.get('enabled', False):
                log("\nğŸ¨ æ­¥éª¤4e: æ·»åŠ LogoåŠ¨ç”»...")
                logo_file_path = Path(logo_config.get('logo_file', './resource/logo/aka.jpg'))

                # æ£€æŸ¥logoæ–‡ä»¶æ˜¯å¦å­˜åœ¨
                if logo_file_path.exists():
                    current_video = final_video_path
                    temp_logo_output = WORK_DIR / "83_temp_with_logo.mp4"

                    if not current_video.exists():
                        log("  âš ï¸  æœªæ‰¾åˆ°æœ€ç»ˆè§†é¢‘ï¼Œè·³è¿‡LogoåŠ¨ç”»", "WARN")
                    else:
                        success = video_composer.add_logo_animation(
                            video_file=str(current_video),
                            logo_file=str(logo_file_path),
                            output_file=str(temp_logo_output),
                            position=logo_config.get('position', 'end'),
                            duration=logo_config.get('duration', 2.0),
                            fadein_time=logo_config.get('fadein_time', 1.0),
                            fadeout_time=logo_config.get('fadeout_time', 0.0),
                            logo_scale=logo_config.get('logo_scale', 0.3)
                        )

                        if success:
                            # åˆ é™¤æ—§æ–‡ä»¶ï¼Œé‡å‘½åæ–°æ–‡ä»¶
                            current_video.unlink()
                            temp_logo_output.rename(current_video)
                            log("  âœ… LogoåŠ¨ç”»æ·»åŠ æˆåŠŸ")
                        else:
                            log("  âš ï¸  Logoæ·»åŠ å¤±è´¥ï¼Œä½¿ç”¨æ— Logoç‰ˆæœ¬", "WARN")
                            # åˆ é™¤å¤±è´¥çš„ä¸´æ—¶æ–‡ä»¶
                            if temp_logo_output.exists():
                                temp_logo_output.unlink()
                else:
                    log(f"  âš ï¸  Logoæ–‡ä»¶ä¸å­˜åœ¨: {logo_file_path}", "WARN")
                    log("  â„¹ï¸  è·³è¿‡Logoæ·»åŠ ")
            else:
                log("  â„¹ï¸  LogoåŠŸèƒ½æœªå¯ç”¨")
        else:
            log("  âŒ æ²¡æœ‰å¯ç”¨çš„è§†é¢‘æ–‡ä»¶ï¼Œæ— æ³•åˆæˆ", "ERROR")

        log(f"âœ“ é˜¶æ®µ4å®Œæˆ\n")

        # æˆæœ¬éªŒè¯
        log("")
        log("=" * 60)
        log("ğŸ’° æˆæœ¬éªŒè¯")
        log("=" * 60)
        final_balance = get_wavespeed_balance()
        if initial_balance is not None and final_balance is not None:
            actual_cost = initial_balance - final_balance
            log(f"åˆå§‹ä½™é¢: ${initial_balance:.4f}")
            log(f"æœ€ç»ˆä½™é¢: ${final_balance:.4f}")
            log(f"å®é™…èŠ±è´¹: ${actual_cost:.4f}")

            # è®¡ç®—é¢„æœŸæˆæœ¬
            image_config = IMAGE_MODEL_CONFIG.get(CURRENT_IMAGE_MODEL, {})
            video_cost_per_shot = get_video_cost(CURRENT_VIDEO_MODEL, resolution)
            character_ref_cost = image_config.get('cost', 0) if user_config.get('character', {}).get('enabled') else 0

            if USE_DIRECT_T2V:
                expected_cost = video_cost_per_shot * shot_count
            else:
                expected_cost = character_ref_cost + (image_config.get('cost', 0) + video_cost_per_shot) * shot_count

            log(f"é¢„æœŸèŠ±è´¹: ${expected_cost:.4f}")

            # è®¡ç®—å·®å¼‚
            diff = actual_cost - expected_cost
            diff_percent = (diff / expected_cost * 100) if expected_cost > 0 else 0

            if abs(diff_percent) > 10:  # å·®å¼‚è¶…è¿‡10%
                if diff > 0:
                    log(f"âš ï¸  å®é™…æˆæœ¬é«˜äºé¢„æœŸ: +${diff:.4f} (+{diff_percent:.1f}%)", "WARN")
                else:
                    log(f"âœ… å®é™…æˆæœ¬ä½äºé¢„æœŸ: ${diff:.4f} ({diff_percent:.1f}%)")
            else:
                log(f"âœ… æˆæœ¬ç¬¦åˆé¢„æœŸ (å·®å¼‚: {diff_percent:.1f}%)")
        else:
            log("âš ï¸  æ— æ³•éªŒè¯æˆæœ¬ï¼ˆä½™é¢æŸ¥è¯¢å¤±è´¥ï¼‰", "WARN")
        log("=" * 60)
        log("")

        # å®Œæˆ
        elapsed = int(time.time() - start_time)
        mins, secs = divmod(elapsed, 60)

        log("=" * 60, "SUCCESS")
        log("ğŸ‰ å¹¿å‘Šè§†é¢‘åˆ¶ä½œå®Œæˆï¼", "SUCCESS")
        log("=" * 60, "SUCCESS")
        log(f"âœ“ è¿è¡ŒID: aka-{RUN_TIMESTAMP}", "SUCCESS")
        log(f"âœ“ è¾“å‡ºç›®å½•: {WORK_DIR.absolute()}", "SUCCESS")
        log(f"âœ“ æœ€ç»ˆè§†é¢‘: {WORK_DIR}/90_final.mp4", "SUCCESS")
        log(f"âœ“ æ—¥å¿—æ–‡ä»¶: {LOG_FILE}", "SUCCESS")
        log(f"âœ“ æ€»è€—æ—¶: {mins}åˆ†{secs}ç§’", "SUCCESS")
        log(f"âœ“ å®Œæˆæ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", "SUCCESS")
        log("=" * 60, "SUCCESS")

    except Exception as e:
        elapsed = int(time.time() - start_time)
        log(f"\nâŒ å‘ç”Ÿé”™è¯¯ï¼š{e}", "ERROR")
        import traceback
        error_trace = traceback.format_exc()
        log(error_trace, "ERROR")
        log(f"å¤±è´¥æ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        log(f"å·²è¿è¡Œ: {elapsed}ç§’")
        log(f"è¾“å‡ºç›®å½•: {WORK_DIR.absolute()}")
        log(f"æ—¥å¿—æ–‡ä»¶: {LOG_FILE}")
        return 1

    return 0

if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser(
        description='Akamai AIæ¨ç†äº‘å¹¿å‘Šè§†é¢‘ç”Ÿæˆç³»ç»Ÿ',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ä½¿ç”¨ç¤ºä¾‹ï¼š
  # æ­£å¸¸æ¨¡å¼ï¼šç”Ÿæˆæ–°çš„å¹¿å‘Šè§†é¢‘
  python3 py/ad-aka.py

  # æ‰¹é‡åˆæˆæ¨¡å¼ï¼šåˆæˆoutputç›®å½•ä¸‹æ‰€æœ‰å­ç›®å½•çš„åˆ†é•œå¤´
  python3 py/ad-aka.py --batch-merge
        """
    )

    parser.add_argument(
        '--batch-merge',
        action='store_true',
        help='æ‰¹é‡åˆæˆæ¨¡å¼ï¼šåˆæˆoutputç›®å½•ä¸‹æ‰€æœ‰aka-*å­ç›®å½•çš„è§†é¢‘åˆ†é•œå¤´'
    )

    args = parser.parse_args()

    # æ ¹æ®æ¨¡å¼é€‰æ‹©æ‰§è¡Œ
    if args.batch_merge:
        exit(batch_merge_all())
    else:
        exit(main())
